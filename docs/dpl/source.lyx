#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass extarticle
\begin_preamble
\usepackage{bitpattern}
\usepackage{lscape}
\usepackage[bookmarks]{hyperref}
\end_preamble
\use_default_options true
\begin_modules
fixltx2e
fix-cm
initials
bicaption
pdfform
pdfcomment
\end_modules
\maintain_unincluded_children false
\language russian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman ccfonts
\font_sans cmss
\font_typewriter cmtt
\font_math newtxmath
\font_default_family rmdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format pdf2
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize 12
\spacing onehalf
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 5
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Part
Приложение 2.
 Исходный код
\end_layout

\begin_layout Section
Структура
\end_layout

\begin_layout Standard
Данный проект содержит в себе две части:
\end_layout

\begin_layout Enumerate
Процессор УП-1.
 
\end_layout

\begin_layout Enumerate
MultiplierGenerator.
 
\end_layout

\begin_layout Subsection
Процессор УП-1
\end_layout

\begin_layout Standard
RTL-описание процессора с RISC-архитектурой.
 Язык описания - Verilog (синтезируемая часть стандарта).
 
\end_layout

\begin_layout Standard
Проекту принадлежат следующие файлы:
\end_layout

\begin_layout Enumerate
adder.v - Сумматор с параллельным переносом
\end_layout

\begin_layout Enumerate
alu.v - Арифметико-логическое устройство
\end_layout

\begin_layout Enumerate
execute.v - Стадия 
\begin_inset Quotes fld
\end_inset

Execute
\begin_inset Quotes frd
\end_inset

 конвейера
\end_layout

\begin_layout Enumerate
gpio.v - Периферийное устройство 
\begin_inset Quotes fld
\end_inset

Контроллер GPIO
\begin_inset Quotes frd
\end_inset


\end_layout

\begin_layout Enumerate
gpio_mux.v - Периферийное устройство 
\begin_inset Quotes fld
\end_inset

Выходной мультиплексор
\begin_inset Quotes frd
\end_inset


\end_layout

\begin_layout Enumerate
insn_decoder.v - Стадия 
\begin_inset Quotes fld
\end_inset

Decode
\begin_inset Quotes frd
\end_inset

 конвейера
\end_layout

\begin_layout Enumerate
memory_op.v - Стадия 
\begin_inset Quotes fld
\end_inset

Memory/Periph
\begin_inset Quotes frd
\end_inset

 конвейера
\end_layout

\begin_layout Enumerate
pipeline_interface.v - Стадия 
\begin_inset Quotes fld
\end_inset

Interface
\begin_inset Quotes frd
\end_inset

 конвейера
\end_layout

\begin_layout Enumerate
ram.v - ОЗУ процессора
\end_layout

\begin_layout Enumerate
register_wb.v - Стадия 
\begin_inset Quotes fld
\end_inset

Register WB
\begin_inset Quotes frd
\end_inset

 конвейера
\end_layout

\begin_layout Enumerate
regs.v - Регистровый файл процессора
\end_layout

\begin_layout Enumerate
shift.v - Комбинированный регистр быстрого сдвига/вращения
\end_layout

\begin_layout Enumerate
test_periph_assembly.v - Модуль верхнего уровня для периферических устройств
\end_layout

\begin_layout Enumerate
test_pipeline_assembly.v - Модуль верхнего уровня для конвейера
\end_layout

\begin_layout Enumerate
test_processor_assembly.v - Модуль верхнего уровня для процессорной системы
\end_layout

\begin_layout Enumerate
main.v - Главный тестовый модуль процессора, с двумя тестовыми программами
\end_layout

\begin_layout Subsection
MultiplierGenerator
\end_layout

\begin_layout Standard
Генератор умножителей по схеме Дадды.
 Язык программирования - С++ (стандарт С++14).
\end_layout

\begin_layout Standard
Проекту принадлежат следующие файлы:
\end_layout

\begin_layout Enumerate
Gate.hpp - Главная логика сборки умножителей и необходимые для этого примитивы
 (заголовочный файл с кодом).
\end_layout

\begin_layout Enumerate
Main.cpp - Точка входа приложения.
 Главная логика работы приложения, а именно порядок приёма аргументов и
 консольный интерфейс.
\end_layout

\begin_layout Enumerate
testcase.v - Схема для тестирования сгенерированных умножителей.
 Язык описания - Verilog.
\end_layout

\begin_layout Section
Исходные коды
\end_layout

\begin_layout Subsection
Процессор УП-1
\end_layout

\begin_layout Subsubsection
adder.v
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Verilog,numbers=left,basicstyle={\scriptsize\ttfamily},breaklines=true,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

`timescale 1 ns / 100 ps
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module fa_pg(a, b, cin, s, p, g);
\end_layout

\begin_layout Plain Layout

    input a, b, cin;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output wire s, p, g;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire w1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	xor x1(p, a, b);
\end_layout

\begin_layout Plain Layout

	xor x2(s, p, cin);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    and a1(g, a, b);
\end_layout

\begin_layout Plain Layout

//    or #1 o1(p, a, b);
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module cla_4(a, b, cin, s, pg, gg);
\end_layout

\begin_layout Plain Layout

    input [3:0] a;
\end_layout

\begin_layout Plain Layout

    input [3:0] b;
\end_layout

\begin_layout Plain Layout

    output wire [3:0] s;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input cin;
\end_layout

\begin_layout Plain Layout

    output wire pg, gg;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [3:0] p;
\end_layout

\begin_layout Plain Layout

    wire [3:0] g;
\end_layout

\begin_layout Plain Layout

    wire [2:0] c;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    fa_pg fa0(a[0], b[0],  cin, s[0], p[0], g[0]);
\end_layout

\begin_layout Plain Layout

    fa_pg fa1(a[1], b[1], c[0], s[1], p[1], g[1]);
\end_layout

\begin_layout Plain Layout

    fa_pg fa2(a[2], b[2], c[1], s[2], p[2], g[2]);
\end_layout

\begin_layout Plain Layout

    fa_pg fa3(a[3], b[3], c[2], s[3], p[3], g[3]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign c[0] = g[0] | p[0]&cin;
\end_layout

\begin_layout Plain Layout

    assign c[1] = g[1] | g[0]&p[1] | cin&p[0]&p[1];
\end_layout

\begin_layout Plain Layout

    assign c[2] = g[2] | g[1]&p[2] | g[0]&p[1]&p[2] | cin&p[0]&p[1]&p[2];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign pg = p[0]&p[1]&p[2]&p[3];
\end_layout

\begin_layout Plain Layout

    assign gg = g[3] | g[2]&p[3] | g[1]&p[3]&p[2] | g[0]&p[3]&p[2]&p[1];
\end_layout

\begin_layout Plain Layout

    //assign cout = gg | cin&pg;
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module cla_16(a, b, cin, s, pg, gg);
\end_layout

\begin_layout Plain Layout

    input [15:0] a;
\end_layout

\begin_layout Plain Layout

    input [15:0] b;
\end_layout

\begin_layout Plain Layout

    output wire [15:0] s;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input cin;
\end_layout

\begin_layout Plain Layout

    output wire pg, gg;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [3:0] p;
\end_layout

\begin_layout Plain Layout

    wire [3:0] g;
\end_layout

\begin_layout Plain Layout

    wire [2:0] c;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    cla_4 cla0(a[3:0],     b[3:0],  cin,   s[3:0], p[0], g[0]);
\end_layout

\begin_layout Plain Layout

    cla_4 cla1(a[7:4],     b[7:4], c[0],   s[7:4], p[1], g[1]);
\end_layout

\begin_layout Plain Layout

    cla_4 cla2(a[11:8],   b[11:8], c[1],  s[11:8], p[2], g[2]);
\end_layout

\begin_layout Plain Layout

    cla_4 cla3(a[15:12], b[15:12], c[2], s[15:12], p[3], g[3]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign c[0] = g[0] | p[0]&cin;
\end_layout

\begin_layout Plain Layout

    assign c[1] = g[1] | g[0]&p[1] | cin&p[0]&p[1];
\end_layout

\begin_layout Plain Layout

    assign c[2] = g[2] | g[1]&p[2] | g[0]&p[1]&p[2] | cin&p[0]&p[1]&p[2];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign pg = p[0]&p[1]&p[2]&p[3];
\end_layout

\begin_layout Plain Layout

    assign gg = g[3] | g[2]&p[3] | g[1]&p[3]&p[2] | g[0]&p[3]&p[2]&p[1];
\end_layout

\begin_layout Plain Layout

    //assign cout = gg | cin&pg;
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module cla_32(a, b, cin, s, cout);
\end_layout

\begin_layout Plain Layout

    input [31:0] a;
\end_layout

\begin_layout Plain Layout

    input [31:0] b;
\end_layout

\begin_layout Plain Layout

    output wire [31:0] s;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input cin;
\end_layout

\begin_layout Plain Layout

    output wire cout;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [3:0] p;
\end_layout

\begin_layout Plain Layout

    wire [3:0] g;
\end_layout

\begin_layout Plain Layout

    wire [2:0] c;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    cla_16 cla0(a[15:0],   b[15:0],  cin,   s[15:0], p[0], g[0]);
\end_layout

\begin_layout Plain Layout

    cla_16 cla1(a[31:16], b[31:16], c[0],  s[31:16], p[1], g[1]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign c[0] = g[0] | p[0]&cin;
\end_layout

\begin_layout Plain Layout

    assign cout = g[1] | g[0]&p[1] | cin&p[0]&p[1];
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module cla_64(a, b, cin, s, cout);
\end_layout

\begin_layout Plain Layout

    input [63:0] a;
\end_layout

\begin_layout Plain Layout

    input [63:0] b;
\end_layout

\begin_layout Plain Layout

    output wire [63:0] s;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input cin;
\end_layout

\begin_layout Plain Layout

    wire pg, gg;
\end_layout

\begin_layout Plain Layout

    output wire cout;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [3:0] p;
\end_layout

\begin_layout Plain Layout

    wire [3:0] g;
\end_layout

\begin_layout Plain Layout

    wire [2:0] c;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    cla_16 cla0(a[15:0],   b[15:0],  cin,  s[15:0], p[0], g[0]);
\end_layout

\begin_layout Plain Layout

    cla_16 cla1(a[31:16], b[31:16], c[0], s[31:16], p[1], g[1]);
\end_layout

\begin_layout Plain Layout

    cla_16 cla2(a[47:32], b[47:32], c[1], s[47:32], p[2], g[2]);
\end_layout

\begin_layout Plain Layout

    cla_16 cla3(a[63:48], b[63:48], c[2], s[63:48], p[3], g[3]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign c[0] = g[0] | p[0]&cin;
\end_layout

\begin_layout Plain Layout

    assign c[1] = g[1] | g[0]&p[1] | cin&p[0]&p[1];
\end_layout

\begin_layout Plain Layout

    assign c[2] = g[2] | g[1]&p[2] | g[0]&p[1]&p[2] | cin&p[0]&p[1]&p[2];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign pg = p[0]&p[1]&p[2]&p[3];
\end_layout

\begin_layout Plain Layout

    assign gg = g[3] | g[2]&p[3] | g[1]&p[3]&p[2] | g[0]&p[3]&p[2]&p[1];
\end_layout

\begin_layout Plain Layout

    assign cout = gg | cin&pg;
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
alu.v
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Verilog,numbers=left,basicstyle={\scriptsize\rmfamily},breaklines=true,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

`include "mult.v"
\end_layout

\begin_layout Plain Layout

`include "adder.v"
\end_layout

\begin_layout Plain Layout

`include "shift.v"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module addsub_32(q, a, b, sub, ov, sov, z);
\end_layout

\begin_layout Plain Layout

    input [31:0] a, b;
\end_layout

\begin_layout Plain Layout

    input sub;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output wire [31:0] q;
\end_layout

\begin_layout Plain Layout

    output ov, sov, z;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] bm = sub ? ~b : b;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    cla_32 cla0(a, bm, sub, q, ov);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign z = ~|q;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign sov = (!a[31]) && (!b[31]) ? ov : (a[31] && b[31] ? ~q[31] :
 1'b0);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module mul_32(q1, q2, ov, z, a, b);
\end_layout

\begin_layout Plain Layout

    input [31:0] a, b;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output wire [31:0] q1, q2;
\end_layout

\begin_layout Plain Layout

    output ov, z;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [63:0] q;
\end_layout

\begin_layout Plain Layout

    assign q1 = q[31:0];
\end_layout

\begin_layout Plain Layout

    assign q2 = q[63:32];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    mult_32 m0( a, b, q);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign ov = |(q2);
\end_layout

\begin_layout Plain Layout

    assign z = ~|({q2, q1});
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module bitwise_32(q, z, a, b, op);
\end_layout

\begin_layout Plain Layout

    input [31:0] a, b;
\end_layout

\begin_layout Plain Layout

    input [2:0] op;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output reg [31:0] q;
\end_layout

\begin_layout Plain Layout

    output wire z;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign z = ~|q;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    always @* begin
\end_layout

\begin_layout Plain Layout

        case(op)
\end_layout

\begin_layout Plain Layout

            3'b000: q = ~ a; //NOT A
\end_layout

\begin_layout Plain Layout

            3'b001: q = a & b; // A AND B
\end_layout

\begin_layout Plain Layout

            3'b010: q = a | b; // A OR B
\end_layout

\begin_layout Plain Layout

            3'b011: q = a ^ b; // A XOR B
\end_layout

\begin_layout Plain Layout

            3'b100: q = ~(a & b); // A NAND B
\end_layout

\begin_layout Plain Layout

            3'b101: q = ~(a | b); // A NOR B
\end_layout

\begin_layout Plain Layout

            3'b110: q = ~(a ^ b); // A XNOR B
\end_layout

\begin_layout Plain Layout

            3'b111: q = ~ b; // NOT B (placeholder)
\end_layout

\begin_layout Plain Layout

        endcase
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module alu32_2x2(q0, q1, st, a, b, op);
\end_layout

\begin_layout Plain Layout

    input [31:0] a, b;
\end_layout

\begin_layout Plain Layout

    output reg [31:0] q0, q1;
\end_layout

\begin_layout Plain Layout

    //wire [31:0] q0, q1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input [7:0] op;
\end_layout

\begin_layout Plain Layout

    output reg [3:0] st; //0 - V, 1 - C, 2 - Z, 3 - N
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] addsub;
\end_layout

\begin_layout Plain Layout

    reg [31:0] addsub_a, addsub_b;
\end_layout

\begin_layout Plain Layout

    wire addsub_z, addsub_ov, addsub_sov;
\end_layout

\begin_layout Plain Layout

    reg subtract;
\end_layout

\begin_layout Plain Layout

    addsub_32 as0(addsub, addsub_a, addsub_b, subtract, addsub_ov, addsub_sov,
 addsub_z);
\end_layout

\begin_layout Plain Layout

    wire [3:0] addsub_st = {addsub[31], addsub_z, addsub_ov, addsub_sov};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] shift;
\end_layout

\begin_layout Plain Layout

    wire shift_z, shift_ov;
\end_layout

\begin_layout Plain Layout

    reg rotate, left, arithmetic;
\end_layout

\begin_layout Plain Layout

    bshift_32 sh0(shift, shift_ov, shift_z, a, b[4:0], rotate, left, arithmetic)
;
\end_layout

\begin_layout Plain Layout

    wire [3:0] shift_st = {shift[31], shift_z, shift_ov, 1'b0};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] mull, mulh;
\end_layout

\begin_layout Plain Layout

    wire mul_z, mul_ov;
\end_layout

\begin_layout Plain Layout

    mul_32 mul0(mull, mulh, mul_ov, mul_z, a, b);
\end_layout

\begin_layout Plain Layout

    wire [3:0] mul_st = {1'b0, mul_z, mul_ov, 1'b0};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] bws;
\end_layout

\begin_layout Plain Layout

    wire bws_z;
\end_layout

\begin_layout Plain Layout

    reg [2:0] b_op;
\end_layout

\begin_layout Plain Layout

    bitwise_32 bw0(bws, bws_z, a, b, b_op);
\end_layout

\begin_layout Plain Layout

    wire [3:0] bws_st = {1'b0, bws_z, 2'b0};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    always @* begin
\end_layout

\begin_layout Plain Layout

        case(op)
\end_layout

\begin_layout Plain Layout

        8'h00: begin //NOP
\end_layout

\begin_layout Plain Layout

            q0 = a;
\end_layout

\begin_layout Plain Layout

            q1 = b;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            st = 4'b0;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        8'h01: begin //ADD
\end_layout

\begin_layout Plain Layout

            subtract = 0;
\end_layout

\begin_layout Plain Layout

            addsub_a = a;
\end_layout

\begin_layout Plain Layout

            addsub_b = b;
\end_layout

\begin_layout Plain Layout

            q0 = addsub;
\end_layout

\begin_layout Plain Layout

            q1 = 32'b0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            st = addsub_st;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        8'h02: begin //SUB
\end_layout

\begin_layout Plain Layout

            subtract = 1;
\end_layout

\begin_layout Plain Layout

            addsub_a = a;
\end_layout

\begin_layout Plain Layout

            addsub_b = b;
\end_layout

\begin_layout Plain Layout

            q0 = addsub;
\end_layout

\begin_layout Plain Layout

            q1 = 32'b0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            st = addsub_st;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        8'h03: begin //CPL
\end_layout

\begin_layout Plain Layout

            subtract = 1;
\end_layout

\begin_layout Plain Layout

            addsub_a = 32'b0;
\end_layout

\begin_layout Plain Layout

            addsub_b = a;
\end_layout

\begin_layout Plain Layout

            q0 = addsub;
\end_layout

\begin_layout Plain Layout

            q1 = 32'b0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            st = addsub_st;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        8'h04: begin //MUL
\end_layout

\begin_layout Plain Layout

            q0 = mull;
\end_layout

\begin_layout Plain Layout

            q1 = mulh;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            st = mul_st;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        8'h05: begin //SHR
\end_layout

\begin_layout Plain Layout

            rotate = 0;
\end_layout

\begin_layout Plain Layout

            left = 0;
\end_layout

\begin_layout Plain Layout

            arithmetic = 0;
\end_layout

\begin_layout Plain Layout

            q0 = shift;
\end_layout

\begin_layout Plain Layout

            q1 = 32'b0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            st = shift_st;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        8'h06: begin // SHL
\end_layout

\begin_layout Plain Layout

            rotate = 0;
\end_layout

\begin_layout Plain Layout

            left = 1;
\end_layout

\begin_layout Plain Layout

            arithmetic = 0;
\end_layout

\begin_layout Plain Layout

            q0 = shift;
\end_layout

\begin_layout Plain Layout

            q1 = 32'b0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            st = shift_st;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        8'h07: begin // SAR
\end_layout

\begin_layout Plain Layout

            rotate = 0;
\end_layout

\begin_layout Plain Layout

            left = 0;
\end_layout

\begin_layout Plain Layout

            arithmetic = 1;
\end_layout

\begin_layout Plain Layout

            q0 = shift;
\end_layout

\begin_layout Plain Layout

            q1 = 32'b0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            st = shift_st;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        8'h08: begin // SAL
\end_layout

\begin_layout Plain Layout

            rotate = 0;
\end_layout

\begin_layout Plain Layout

            left = 1;
\end_layout

\begin_layout Plain Layout

            arithmetic = 1;
\end_layout

\begin_layout Plain Layout

            q0 = shift;
\end_layout

\begin_layout Plain Layout

            q1 = 32'b0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            st = shift_st;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        8'h09: begin // ROR
\end_layout

\begin_layout Plain Layout

            rotate = 1;
\end_layout

\begin_layout Plain Layout

            left = 0;
\end_layout

\begin_layout Plain Layout

            arithmetic = 0;
\end_layout

\begin_layout Plain Layout

            q0 = shift;
\end_layout

\begin_layout Plain Layout

            q1 = 32'b0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            st = shift_st;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        8'h0A: begin // ROL
\end_layout

\begin_layout Plain Layout

            rotate = 1;
\end_layout

\begin_layout Plain Layout

            left = 1;
\end_layout

\begin_layout Plain Layout

            arithmetic = 0;
\end_layout

\begin_layout Plain Layout

            q0 = shift;
\end_layout

\begin_layout Plain Layout

            q1 = 32'b0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            st = shift_st;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        8'h0B: begin //NOT
\end_layout

\begin_layout Plain Layout

            b_op = 0;
\end_layout

\begin_layout Plain Layout

            q0 = bws;
\end_layout

\begin_layout Plain Layout

            q1 = 32'b0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            st = bws_st;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        8'h0C: begin //AND
\end_layout

\begin_layout Plain Layout

            b_op = 1;
\end_layout

\begin_layout Plain Layout

            q0 = bws;
\end_layout

\begin_layout Plain Layout

            q1 = 32'b0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            st = bws_st;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        8'h0D: begin //OR
\end_layout

\begin_layout Plain Layout

            b_op = 2;
\end_layout

\begin_layout Plain Layout

            q0 = bws;
\end_layout

\begin_layout Plain Layout

            q1 = 32'b0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            st = bws_st;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        8'h0E: begin //XOR
\end_layout

\begin_layout Plain Layout

            b_op = 3;
\end_layout

\begin_layout Plain Layout

            q0 = bws;
\end_layout

\begin_layout Plain Layout

            q1 = 32'b0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            st = bws_st;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        8'h0F: begin //NAND
\end_layout

\begin_layout Plain Layout

            b_op = 4;
\end_layout

\begin_layout Plain Layout

            q0 = bws;
\end_layout

\begin_layout Plain Layout

            q1 = 32'b0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            st = bws_st;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        8'h10: begin //NOR
\end_layout

\begin_layout Plain Layout

            b_op = 5;
\end_layout

\begin_layout Plain Layout

            q0 = bws;
\end_layout

\begin_layout Plain Layout

            q1 = 32'b0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            st = bws_st;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        8'h11: begin //XNOR
\end_layout

\begin_layout Plain Layout

            b_op = 6;
\end_layout

\begin_layout Plain Layout

            q0 = bws;
\end_layout

\begin_layout Plain Layout

            q1 = 32'b0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            st = bws_st;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        /*default: begin //invalid
\end_layout

\begin_layout Plain Layout

            q0 = 32'bz;
\end_layout

\begin_layout Plain Layout

            q1 = 32'bz;
\end_layout

\begin_layout Plain Layout

            st = 4'bz;
\end_layout

\begin_layout Plain Layout

        end*/
\end_layout

\begin_layout Plain Layout

    endcase
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
execute.v
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Verilog,numbers=left,basicstyle={\scriptsize\rmfamily},breaklines=true,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

`timescale 1 ns / 100 ps
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

`include "alu.v"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module cond_calc(cr, cc, n, z, c, v);
\end_layout

\begin_layout Plain Layout

    input [3:0] cc;
\end_layout

\begin_layout Plain Layout

    input n, z, c, v;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output reg cr;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    always @* begin
\end_layout

\begin_layout Plain Layout

       case(cc)
\end_layout

\begin_layout Plain Layout

            4'b0000: cr = z == 1'b1; //EQ - equal
\end_layout

\begin_layout Plain Layout

            4'b0001: cr = z == 1'b0; //NEQ - not equal
\end_layout

\begin_layout Plain Layout

            4'b0010: cr = c == 1'b1; //HS - higher or same (unsigned)
\end_layout

\begin_layout Plain Layout

            4'b0011: cr = c == 1'b0; //LO - strictly lower (unsigned)
\end_layout

\begin_layout Plain Layout

            4'b0100: cr = n == 1'b1; //NEG - negative
\end_layout

\begin_layout Plain Layout

            4'b0101: cr = n == 1'b0; //POS - positive
\end_layout

\begin_layout Plain Layout

            4'b0110: cr = v == 1'b1; //SOV - signed overflow
\end_layout

\begin_layout Plain Layout

            4'b0111: cr = v == 1'b0; //NSOV - no signed overflow
\end_layout

\begin_layout Plain Layout

            4'b1000: cr = (c == 1'b1) && (z == 1'b0); //HI - strictly higher
 (unsigned)
\end_layout

\begin_layout Plain Layout

            4'b1001: cr = (c == 1'b0) || (z == 1'b1); //LS - lower or same
 (unsigned)
\end_layout

\begin_layout Plain Layout

            4'b1010: cr = n == v; //GE - greater or equal (signed)
\end_layout

\begin_layout Plain Layout

            4'b1011: cr = n != v; //LT - strictly less (signed)
\end_layout

\begin_layout Plain Layout

            4'b1100: cr = (z == 1'b0) && (n == v); //GT - strictly greater
 (signed)
\end_layout

\begin_layout Plain Layout

            4'b1101: cr = (z == 1'b1) || (n != v); //LE - lower or equal
 (signed)
\end_layout

\begin_layout Plain Layout

            4'b1110: cr = 1'b1; //AL - always
\end_layout

\begin_layout Plain Layout

            4'b1111: cr = 1'b0; //NV - never
\end_layout

\begin_layout Plain Layout

        endcase
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module status_register_adaptor(st, stwr, n, z, c, v, cc);
\end_layout

\begin_layout Plain Layout

    input n, z, c, v;
\end_layout

\begin_layout Plain Layout

    input cc;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output [31:0] st;
\end_layout

\begin_layout Plain Layout

    output stwr;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign stwr = cc;
\end_layout

\begin_layout Plain Layout

    assign st[3:0] = {n, z, c, v};
\end_layout

\begin_layout Plain Layout

    assign st[31:4] = 28'b0;
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module execute_stage_passthrough(qm_a1, qm_a2, qm_r1_op, qm_r2_op, qr_a1,
 qr_a2, qr_op, m_a1, m_a2, m_r1_op, m_r2_op, r_a1, r_a2, r_op, clk, rst);
\end_layout

\begin_layout Plain Layout

    input [31:0] m_a1, m_a2; //(mem_op)
\end_layout

\begin_layout Plain Layout

    input [3:0] m_r1_op, m_r2_op; //(mem_op)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input [4:0] r_a1, r_a2; //(reg_wb)
\end_layout

\begin_layout Plain Layout

    input [3:0] r_op; //(reg_wb)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input clk, rst;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output reg [31:0] qm_a1, qm_a2; //(mem_op)
\end_layout

\begin_layout Plain Layout

    output reg [3:0] qm_r1_op, qm_r2_op; //(mem_op)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output reg [4:0] qr_a1, qr_a2; //(reg_wb)
\end_layout

\begin_layout Plain Layout

    output reg [3:0] qr_op; //(reg_wb)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    always @(posedge clk or posedge rst) begin
\end_layout

\begin_layout Plain Layout

        if(rst) begin
\end_layout

\begin_layout Plain Layout

            qm_a1 <= 32'b0; qm_a2 <= 32'b0;
\end_layout

\begin_layout Plain Layout

            qm_r1_op <= 4'b0; qm_r2_op <= 4'b0;
\end_layout

\begin_layout Plain Layout

            qr_a1 <= 5'b0; qr_a2 <= 5'b0;
\end_layout

\begin_layout Plain Layout

            qr_op <= 4'b0;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        else begin
\end_layout

\begin_layout Plain Layout

            qm_a1 <= m_a1; qm_a2 <= m_a2;
\end_layout

\begin_layout Plain Layout

            qm_r1_op <= m_r1_op; qm_r2_op <= m_r2_op;
\end_layout

\begin_layout Plain Layout

            qr_a1 <= r_a1; qr_a2 <= r_a2;
\end_layout

\begin_layout Plain Layout

            qr_op <= r_op;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module execute(r1, r2, cres, n, z, c, v, cc, a, b, alu_op, is_cond, cond,
 write_flags, st, swp, clk, rst);
\end_layout

\begin_layout Plain Layout

    input [31:0] a, b; //operands
\end_layout

\begin_layout Plain Layout

    input [31:0] st; //status register
\end_layout

\begin_layout Plain Layout

    input [7:0] alu_op; // alu operation
\end_layout

\begin_layout Plain Layout

    input is_cond; //is a conditional command signal
\end_layout

\begin_layout Plain Layout

    input [3:0] cond; //cc
\end_layout

\begin_layout Plain Layout

    input [3:0] write_flags; //write n/z/c/v
\end_layout

\begin_layout Plain Layout

    input swp; //swap ops?
\end_layout

\begin_layout Plain Layout

    input clk, rst;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output reg [31:0] r1, r2; //results, sync
\end_layout

\begin_layout Plain Layout

    output wire n, z, c, v; //flags, async
\end_layout

\begin_layout Plain Layout

    output wire cc; //write flags, async
\end_layout

\begin_layout Plain Layout

    output reg cres; //conditional results, sync
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] ra = swp ? b : a;
\end_layout

\begin_layout Plain Layout

    wire [31:0] rb = swp ? a : b;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] alu_q1, alu_q2;
\end_layout

\begin_layout Plain Layout

    wire alu_n, alu_z, alu_c, alu_v;
\end_layout

\begin_layout Plain Layout

    wire [7:0] alu_op;
\end_layout

\begin_layout Plain Layout

    alu32_2x2 alu0(alu_q1, alu_q2, {alu_n, alu_z, alu_c, alu_v}, ra, rb,
 alu_op);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire cond_n = st[3], cond_z = st[2], cond_c = st[1], cond_v = st[0];
\end_layout

\begin_layout Plain Layout

    wire cond_res;
\end_layout

\begin_layout Plain Layout

    cond_calc cond0(cond_res, cond, cond_n, cond_z, cond_c, cond_v);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign cc = (write_flags != 4'b0) && (is_cond && cond_res);
\end_layout

\begin_layout Plain Layout

    assign n = write_flags[3] ? alu_n : cond_n;
\end_layout

\begin_layout Plain Layout

    assign z = write_flags[2] ? alu_z : cond_z;
\end_layout

\begin_layout Plain Layout

    assign c = write_flags[1] ? alu_c : cond_c;
\end_layout

\begin_layout Plain Layout

    assign v = write_flags[0] ? alu_v : cond_v;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    always @(posedge clk or posedge rst) begin
\end_layout

\begin_layout Plain Layout

        if(rst) begin
\end_layout

\begin_layout Plain Layout

            r1 <= 31'b0;
\end_layout

\begin_layout Plain Layout

            r2 <= 31'b0;
\end_layout

\begin_layout Plain Layout

            cres <= 1'b0;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        else begin
\end_layout

\begin_layout Plain Layout

            r1 <= alu_q1;
\end_layout

\begin_layout Plain Layout

            r2 <= alu_q2;
\end_layout

\begin_layout Plain Layout

            if(is_cond) cres <= cond_res;
\end_layout

\begin_layout Plain Layout

            else cres <= 1'b1;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
gpio.v
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Verilog,numbers=left,basicstyle={\scriptsize\rmfamily},breaklines=true,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

`timescale 1 ns / 100 ps
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module gpio(gpio_out, gpio_in, gpio_dir, addr, sys_w_addr, sys_r_addr, sys_w_lin
e, sys_r_line, sys_w, sys_r, rst, clk);
\end_layout

\begin_layout Plain Layout

    //control signals
\end_layout

\begin_layout Plain Layout

    input [31:0] gpio_in;
\end_layout

\begin_layout Plain Layout

    output wire [31:0] gpio_out;
\end_layout

\begin_layout Plain Layout

    output wire [31:0] gpio_dir;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //address, constant
\end_layout

\begin_layout Plain Layout

    input [31:0] addr;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //peripheral bus
\end_layout

\begin_layout Plain Layout

    input [31:0] sys_w_addr;
\end_layout

\begin_layout Plain Layout

    input [31:0] sys_r_addr;
\end_layout

\begin_layout Plain Layout

    input [31:0] sys_w_line;
\end_layout

\begin_layout Plain Layout

    output reg [31:0] sys_r_line;
\end_layout

\begin_layout Plain Layout

    input sys_w;
\end_layout

\begin_layout Plain Layout

    input sys_r;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //generic
\end_layout

\begin_layout Plain Layout

    input clk;
\end_layout

\begin_layout Plain Layout

    input rst;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //control regs
\end_layout

\begin_layout Plain Layout

    reg [31:0] direction; // 1 for out, 0 for in
\end_layout

\begin_layout Plain Layout

    reg [31:0] value; //default
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign gpio_out = value;
\end_layout

\begin_layout Plain Layout

    assign gpio_dir = direction;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    always @(posedge clk or posedge rst) begin
\end_layout

\begin_layout Plain Layout

        if(rst) begin
\end_layout

\begin_layout Plain Layout

            direction <= 32'b0;
\end_layout

\begin_layout Plain Layout

            value <= 32'b0;
\end_layout

\begin_layout Plain Layout

            sys_r_line <= 32'bz;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        else begin
\end_layout

\begin_layout Plain Layout

            #1;
\end_layout

\begin_layout Plain Layout

            if(sys_r) begin //read requested
\end_layout

\begin_layout Plain Layout

                if(sys_r_addr[31:1] == addr[31:1]) begin //if r addr is
 same
\end_layout

\begin_layout Plain Layout

                    if(sys_r_addr[0]) begin //high part, direction
\end_layout

\begin_layout Plain Layout

                        sys_r_line <= direction;
\end_layout

\begin_layout Plain Layout

                    end else begin //low part, read value
\end_layout

\begin_layout Plain Layout

                        sys_r_line <= gpio_in;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                end else begin
\end_layout

\begin_layout Plain Layout

                    sys_r_line = 32'bz; //don't scramble other devices
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

            end else begin
\end_layout

\begin_layout Plain Layout

                sys_r_line = 32'bz; //minimize power consumption
\end_layout

\begin_layout Plain Layout

            end
\end_layout

\begin_layout Plain Layout

            if(sys_w) begin //write requested
\end_layout

\begin_layout Plain Layout

                if(sys_w_addr[31:1] == addr[31:1]) begin //if w addr is
 same
\end_layout

\begin_layout Plain Layout

                    if(sys_w_addr[0]) begin //high part, direction
\end_layout

\begin_layout Plain Layout

                        direction <= sys_w_line;
\end_layout

\begin_layout Plain Layout

                    end else begin //low part, write value
\end_layout

\begin_layout Plain Layout

                        value <= sys_w_line;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

            end
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
gpio_mux.v
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Verilog,numbers=left,basicstyle={\scriptsize\rmfamily},breaklines=true,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

`timescale 1 ns / 100 ps
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module gpio_mux(pins, func0_in, func1_in, func2_in, func3_in, func0_out,
 func1_out, func2_out, func3_out, func0_dir, func1_dir, func2_dir, func3_dir,
 addr, sys_w_addr, sys_r_addr, sys_w_line, sys_r_line, sys_w, sys_r, rst,
 clk);
\end_layout

\begin_layout Plain Layout

    inout [31:0] pins;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //functions
\end_layout

\begin_layout Plain Layout

    //output signals
\end_layout

\begin_layout Plain Layout

    input [31:0] func0_out;
\end_layout

\begin_layout Plain Layout

    input [31:0] func1_out;
\end_layout

\begin_layout Plain Layout

    input [31:0] func2_out;
\end_layout

\begin_layout Plain Layout

    input [31:0] func3_out;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //input signals
\end_layout

\begin_layout Plain Layout

    output wire [31:0] func0_in;
\end_layout

\begin_layout Plain Layout

    output wire [31:0] func1_in;
\end_layout

\begin_layout Plain Layout

    output wire [31:0] func2_in;
\end_layout

\begin_layout Plain Layout

    output wire [31:0] func3_in;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //direction signals, 1 - out, 0 - in
\end_layout

\begin_layout Plain Layout

    input [31:0] func0_dir;
\end_layout

\begin_layout Plain Layout

    input [31:0] func1_dir;
\end_layout

\begin_layout Plain Layout

    input [31:0] func2_dir;
\end_layout

\begin_layout Plain Layout

    input [31:0] func3_dir;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //address, constant
\end_layout

\begin_layout Plain Layout

    input [31:0] addr;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //peripheral bus
\end_layout

\begin_layout Plain Layout

    input [31:0] sys_w_addr;
\end_layout

\begin_layout Plain Layout

    input [31:0] sys_r_addr;
\end_layout

\begin_layout Plain Layout

    input [31:0] sys_w_line;
\end_layout

\begin_layout Plain Layout

    output reg [31:0] sys_r_line;
\end_layout

\begin_layout Plain Layout

    input sys_w;
\end_layout

\begin_layout Plain Layout

    input sys_r;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //generic
\end_layout

\begin_layout Plain Layout

    input clk;
\end_layout

\begin_layout Plain Layout

    input rst;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //pin control register;
\end_layout

\begin_layout Plain Layout

    reg [63:0] control;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //generate muxes for every pin
\end_layout

\begin_layout Plain Layout

    genvar i;
\end_layout

\begin_layout Plain Layout

    generate
\end_layout

\begin_layout Plain Layout

    for(i = 0; i < 32; i = i + 1) begin : pin_mux
\end_layout

\begin_layout Plain Layout

        wire [1:0] pin_control = control[(i*2 + 1):(i*2)];
\end_layout

\begin_layout Plain Layout

        wire pin_out = pin_control == 0 ? func0_out[i] : (pin_control ==
 1 ? func1_out[i] : (pin_control == 2 ? func2_out[i] : func3_out[i]));
\end_layout

\begin_layout Plain Layout

        wire pin_dir = pin_control == 0 ? func0_dir[i] : (pin_control ==
 1 ? func1_dir[i] : (pin_control == 2 ? func2_dir[i] : func3_dir[i]));
\end_layout

\begin_layout Plain Layout

        assign pins[i] = pin_dir == 1 ? pin_out : 1'bz;
\end_layout

\begin_layout Plain Layout

        assign func0_in[i] = pin_dir == 1 ? pin_out : pins[i];
\end_layout

\begin_layout Plain Layout

        assign func1_in[i] = pin_dir == 1 ? pin_out : pins[i];
\end_layout

\begin_layout Plain Layout

        assign func2_in[i] = pin_dir == 1 ? pin_out : pins[i];
\end_layout

\begin_layout Plain Layout

        assign func3_in[i] = pin_dir == 1 ? pin_out : pins[i];
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

    endgenerate
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    always @(posedge clk or posedge rst) begin
\end_layout

\begin_layout Plain Layout

        #1;
\end_layout

\begin_layout Plain Layout

        if(rst) begin
\end_layout

\begin_layout Plain Layout

            control = 64'b0;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        else begin
\end_layout

\begin_layout Plain Layout

            if(sys_r) begin //read requested
\end_layout

\begin_layout Plain Layout

                if(sys_r_addr[31:1] == addr[31:1]) begin //if r addr is
 same
\end_layout

\begin_layout Plain Layout

                    if(sys_r_addr[0]) begin //high part
\end_layout

\begin_layout Plain Layout

                        sys_r_line <= control[63:32];
\end_layout

\begin_layout Plain Layout

                    end else begin //low part
\end_layout

\begin_layout Plain Layout

                        sys_r_line <= control[31:0];
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                end else begin
\end_layout

\begin_layout Plain Layout

                    sys_r_line = 32'bz; //don't scramble other devices
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

            end else begin
\end_layout

\begin_layout Plain Layout

                sys_r_line = 32'bz; //minimize power consumption
\end_layout

\begin_layout Plain Layout

            end
\end_layout

\begin_layout Plain Layout

            if(sys_w) begin //write requested
\end_layout

\begin_layout Plain Layout

                if(sys_w_addr[31:1] == addr[31:1]) begin //if w addr is
 same
\end_layout

\begin_layout Plain Layout

                    if(sys_w_addr[0]) begin //high part
\end_layout

\begin_layout Plain Layout

                        control[63:32] <= sys_w_line;
\end_layout

\begin_layout Plain Layout

                    end else begin //low part
\end_layout

\begin_layout Plain Layout

                        control[31:0] <= sys_w_line;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

            end
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
insn_decoder.v
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Verilog,numbers=left,basicstyle={\scriptsize\rmfamily},breaklines=true,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

`timescale 1 ns / 100 ps
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//fixed version
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/*module insn_type_lookup(type, opcode);
\end_layout

\begin_layout Plain Layout

    input [6:0] opcode;
\end_layout

\begin_layout Plain Layout

    output [2:0] type;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    always @(a or b) begin
\end_layout

\begin_layout Plain Layout

        case(opcode) //full_case parallel_case
\end_layout

\begin_layout Plain Layout

            0: type <= 0;
\end_layout

\begin_layout Plain Layout

            1: type <= 0;
\end_layout

\begin_layout Plain Layout

            //...
\end_layout

\begin_layout Plain Layout

        endcase
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

endmodule*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module reg_hazard_checker(ex_hazard, mem_hazard, reg_hazard, ex_r1_a, ex_r2_a,
 ex_r_op, ex_proceed, mem_r1_a, mem_r2_a, mem_r_op, mem_proceed, reg_r1_a,
 reg_r2_a, reg_write, dec_r1_addr, dec_r2_addr, dec_r_read);
\end_layout

\begin_layout Plain Layout

    output wire ex_hazard;
\end_layout

\begin_layout Plain Layout

    output wire mem_hazard;
\end_layout

\begin_layout Plain Layout

    output wire reg_hazard;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input [4:0] ex_r1_a, ex_r2_a;
\end_layout

\begin_layout Plain Layout

    input [3:0] ex_r_op;
\end_layout

\begin_layout Plain Layout

    input ex_proceed;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input [4:0] mem_r1_a, mem_r2_a;
\end_layout

\begin_layout Plain Layout

    input [3:0] mem_r_op;
\end_layout

\begin_layout Plain Layout

    input mem_proceed;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input [4:0] reg_r1_a, reg_r2_a;
\end_layout

\begin_layout Plain Layout

    input [1:0] reg_write;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input [4:0] dec_r1_addr, dec_r2_addr;
\end_layout

\begin_layout Plain Layout

    input [1:0] dec_r_read;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire dec_r1_read_comp = dec_r_read[0];
\end_layout

\begin_layout Plain Layout

    wire dec_r2_read_comp = dec_r_read[1];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire ex_r1_op_comp = (ex_r_op == 1) || (ex_r_op == 2) || (ex_r_op ==
 3);
\end_layout

\begin_layout Plain Layout

    wire ex_r2_op_comp = (ex_r_op == 4) || (ex_r_op == 5) || (ex_r_op ==
 6);
\end_layout

\begin_layout Plain Layout

    wire ex_r1r2_op_comp = (ex_r_op == 7) || (ex_r_op == 8);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire ex_r1_comp = (ex_r1_a == dec_r1_addr);
\end_layout

\begin_layout Plain Layout

    wire ex_r2_comp = (ex_r2_a == dec_r2_addr);
\end_layout

\begin_layout Plain Layout

    wire ex_r1r2_comp = (ex_r1_a == dec_r2_addr);
\end_layout

\begin_layout Plain Layout

    wire ex_r2r1_comp = (ex_r2_a == dec_r1_addr);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire ex_hazard_r1 = ((ex_r1_op_comp || ex_r1r2_op_comp) && ex_r1_comp
 && dec_r1_read_comp);
\end_layout

\begin_layout Plain Layout

    wire ex_hazard_r2 = ((ex_r2_op_comp || ex_r1r2_op_comp) && ex_r2_comp
 && dec_r2_read_comp);
\end_layout

\begin_layout Plain Layout

    wire ex_hazard_r1r2 = ((ex_r1_op_comp || ex_r1r2_op_comp) && ex_r1r2_comp
 && dec_r2_read_comp);
\end_layout

\begin_layout Plain Layout

    wire ex_hazard_r2r1 = ((ex_r2_op_comp || ex_r1r2_op_comp) && ex_r2r1_comp
 && dec_r1_read_comp);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign ex_hazard =  (ex_hazard_r1 || ex_hazard_r2 || ex_hazard_r1r2
 || ex_hazard_r2r1) && ex_proceed;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire mem_r1_op_comp = (mem_r_op == 1) || (mem_r_op == 2) || (mem_r_op
 == 3);
\end_layout

\begin_layout Plain Layout

    wire mem_r2_op_comp = (mem_r_op == 4) || (mem_r_op == 5) || (mem_r_op
 == 6);
\end_layout

\begin_layout Plain Layout

    wire mem_r1r2_op_comp = (mem_r_op == 7) || (mem_r_op == 8);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire mem_r1_comp = (mem_r1_a == dec_r1_addr);
\end_layout

\begin_layout Plain Layout

    wire mem_r2_comp = (mem_r2_a == dec_r2_addr);
\end_layout

\begin_layout Plain Layout

    wire mem_r1r2_comp = (mem_r1_a == dec_r2_addr);
\end_layout

\begin_layout Plain Layout

    wire mem_r2r1_comp = (mem_r2_a == dec_r1_addr);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire mem_hazard_r1 = ((mem_r1_op_comp || mem_r1r2_op_comp) && mem_r1_comp
 && dec_r1_read_comp);
\end_layout

\begin_layout Plain Layout

    wire mem_hazard_r2 = ((mem_r2_op_comp || mem_r1r2_op_comp) && mem_r2_comp
 && dec_r2_read_comp);
\end_layout

\begin_layout Plain Layout

    wire mem_hazard_r1r2 = ((mem_r1_op_comp || mem_r1r2_op_comp) && mem_r1r2_com
p && dec_r2_read_comp);
\end_layout

\begin_layout Plain Layout

    wire mem_hazard_r2r1 = ((mem_r2_op_comp || mem_r1r2_op_comp) && mem_r2r1_com
p && dec_r1_read_comp);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign mem_hazard =  (mem_hazard_r1 || mem_hazard_r2 || mem_hazard_r1r2
 || mem_hazard_r2r1) && mem_proceed;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire reg_r1_write_comp = reg_write[0];
\end_layout

\begin_layout Plain Layout

    wire reg_r2_write_comp = reg_write[1];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire reg_r1_comp = (reg_r1_a == dec_r1_addr);
\end_layout

\begin_layout Plain Layout

    wire reg_r2_comp = (reg_r2_a == dec_r2_addr);
\end_layout

\begin_layout Plain Layout

    wire reg_r1r2_comp = (reg_r1_a == dec_r2_addr);
\end_layout

\begin_layout Plain Layout

    wire reg_r2r1_comp = (reg_r2_a == dec_r1_addr);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire reg_hazard_r1 = (reg_r1_write_comp && reg_r1_comp && dec_r1_read_comp);
\end_layout

\begin_layout Plain Layout

    wire reg_hazard_r2 = (reg_r2_write_comp && reg_r2_comp && dec_r2_read_comp);
\end_layout

\begin_layout Plain Layout

    wire reg_hazard_r1r2 = (reg_r1_write_comp && reg_r1r2_comp && dec_r2_read_co
mp);
\end_layout

\begin_layout Plain Layout

    wire reg_hazard_r2r1 = (reg_r2_write_comp && reg_r2r1_comp && dec_r1_read_co
mp);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign reg_hazard =  reg_hazard_r1 || reg_hazard_r2 || reg_hazard_r1r2
 || reg_hazard_r2r1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module insn_decoder( e_a, e_b, e_alu_op, e_is_cond, e_cond, e_write_flags,
 e_swp, m_a1, m_a2, m_r1_op, m_r2_op, r_a1, r_a2, r_op, d_pass, d_pcincr,
 r_r1_addr, r_r2_addr, r_read, word, r1, r2, hazard, rst, clk);
\end_layout

\begin_layout Plain Layout

    output reg [31:0] e_a, e_b;
\end_layout

\begin_layout Plain Layout

    output reg [7:0] e_alu_op;
\end_layout

\begin_layout Plain Layout

    output reg [3:0] e_cond;
\end_layout

\begin_layout Plain Layout

    output reg [3:0] e_write_flags;
\end_layout

\begin_layout Plain Layout

    output reg e_swp;
\end_layout

\begin_layout Plain Layout

    output reg e_is_cond;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output reg [31:0] m_a1, m_a2;
\end_layout

\begin_layout Plain Layout

    output reg [3:0] m_r1_op, m_r2_op;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output reg [4:0] r_a1, r_a2;
\end_layout

\begin_layout Plain Layout

    output reg [3:0] r_op;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output reg d_pass;
\end_layout

\begin_layout Plain Layout

    output reg d_pcincr;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output reg [4:0] r_r1_addr, r_r2_addr;
\end_layout

\begin_layout Plain Layout

    output reg [1:0] r_read;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input [31:0] word;
\end_layout

\begin_layout Plain Layout

    input [31:0] r1, r2;
\end_layout

\begin_layout Plain Layout

    input hazard;
\end_layout

\begin_layout Plain Layout

    input rst, clk;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    reg [7:0] state1;
\end_layout

\begin_layout Plain Layout

    reg fetch;
\end_layout

\begin_layout Plain Layout

    reg reg_fetch;
\end_layout

\begin_layout Plain Layout

    reg [3:0] delay_counter;
\end_layout

\begin_layout Plain Layout

    reg [2:0] imm_action; // 000 - nop, 001 - imm1 -> b, 010 - imm1 -> a,
 011 {imm1, imm2} -> {a,b}, 100 - nop? 101..111 - as 001..011 but a ~ m_a2,
 b ~ m_a1
\end_layout

\begin_layout Plain Layout

    //reg [1:0] imm_counter;
\end_layout

\begin_layout Plain Layout

    reg [7:0] old_state1_imm;
\end_layout

\begin_layout Plain Layout

    reg old_pass_imm, old_fetch_imm, old_pcincr_imm;
\end_layout

\begin_layout Plain Layout

    reg [1:0] r_to_mem; //00 a,b; 01 m1, b; 10 a, m2; 11 m1, m2
\end_layout

\begin_layout Plain Layout

    reg [7:0] old_state1_hz;
\end_layout

\begin_layout Plain Layout

    reg old_pass_hz, old_fetch_hz, old_pcincr_hz;
\end_layout

\begin_layout Plain Layout

    reg set_delay;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    reg [6:0] opcode;
\end_layout

\begin_layout Plain Layout

    reg [3:0] cond;
\end_layout

\begin_layout Plain Layout

//    reg [1:0] imm;
\end_layout

\begin_layout Plain Layout

    reg [4:0] reg_a_addr, reg_b_addr;
\end_layout

\begin_layout Plain Layout

    reg [4:0] reg_c_addr, reg_d_addr;
\end_layout

\begin_layout Plain Layout

    reg stage1,stage2, stage3, stage4;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    always @(posedge clk or posedge rst) begin
\end_layout

\begin_layout Plain Layout

        #1;
\end_layout

\begin_layout Plain Layout

        if(rst) begin
\end_layout

\begin_layout Plain Layout

            e_a <= 31'b0; e_b <= 31'b0;
\end_layout

\begin_layout Plain Layout

            e_alu_op <= 8'b0; //NOP
\end_layout

\begin_layout Plain Layout

            e_cond <= 4'b0;
\end_layout

\begin_layout Plain Layout

            e_write_flags = 4'b0;
\end_layout

\begin_layout Plain Layout

            e_swp <= 1'b0; e_is_cond <= 1'b0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            m_a1 <= 31'b0; m_a2 <= 31'b0;
\end_layout

\begin_layout Plain Layout

            m_r1_op <= 4'b0; m_r2_op <= 4'b0; //clean NOP
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            r_a1 <= 5'b0; r_a2 <= 5'b0;
\end_layout

\begin_layout Plain Layout

            r_op <= 4'b0; //NOP;
\end_layout

\begin_layout Plain Layout

            d_pass <= 1'b0; d_pcincr <= 1'b1;
\end_layout

\begin_layout Plain Layout

            r_r1_addr <= 5'b0; r_r2_addr <= 5'b0;
\end_layout

\begin_layout Plain Layout

            r_read <= 2'b0;
\end_layout

\begin_layout Plain Layout

            state1 <= 0; fetch <= 1; reg_fetch <= 0;
\end_layout

\begin_layout Plain Layout

            old_pass_imm <= 0; old_fetch_imm <= 0; old_pcincr_imm <= 0;
 old_state1_imm <= 0;
\end_layout

\begin_layout Plain Layout

            old_pass_hz <= 0; old_fetch_hz <= 0; old_pcincr_hz <= 0; old_state1_
hz <= 0;
\end_layout

\begin_layout Plain Layout

            set_delay <= 0;
\end_layout

\begin_layout Plain Layout

            opcode <= 0;
\end_layout

\begin_layout Plain Layout

            delay_counter <= 4'b0;
\end_layout

\begin_layout Plain Layout

            imm_action <= 3'b0;
\end_layout

\begin_layout Plain Layout

            r_to_mem <= 0;
\end_layout

\begin_layout Plain Layout

            stage1 <= 0;stage2 <= 0;stage3 <= 0; stage4 <= 0;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        else begin
\end_layout

\begin_layout Plain Layout

            /*case(state1)
\end_layout

\begin_layout Plain Layout

                0: begin opcode = word[31:25];
\end_layout

\begin_layout Plain Layout

                        cond <= word[24:21];
\end_layout

\begin_layout Plain Layout

                        reg_a_addr <= word[20:16]; reg_b_addr <= word[15:11];
 reg_c_addr <= word[10:5]; reg_d_addr <= word[4:0];
\end_layout

\begin_layout Plain Layout

                        imm <= word[4:3];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                    state1 <= 1;
\end_layout

\begin_layout Plain Layout

                    state2 <= opcode;
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                1:
\end_layout

\begin_layout Plain Layout

            endcase
\end_layout

\begin_layout Plain Layout

            //state 1 is for decoding
\end_layout

\begin_layout Plain Layout

            //state 2 is for opcode setup
\end_layout

\begin_layout Plain Layout

            //state 3 is for additional operations
\end_layout

\begin_layout Plain Layout

            case(state2)
\end_layout

\begin_layout Plain Layout

                0: begin //nop
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 0; e_cond <= 0; e_write_flags <= 0; e_is_cond
 <= 0;
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b0; m_r2_op <= 4'b0;
\end_layout

\begin_layout Plain Layout

                    r_op <= 0; r_read <= 0; d_pass <= 1 d_pcincr <= 1;
\end_layout

\begin_layout Plain Layout

                    state1 <= 0;
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                1: begin //or
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h0D; e_cond <= cond; e_write_flags <=
 4'hF; e_is_cond <= 1;
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b0; m_r2_op <= 4'b0;
\end_layout

\begin_layout Plain Layout

                    r_op <= 2; //if respective imm r_read = 0, d_pass =
 0, d_pcincr = 1;
\end_layout

\begin_layout Plain Layout

            */
\end_layout

\begin_layout Plain Layout

            if(fetch) begin
\end_layout

\begin_layout Plain Layout

                opcode = word[31:25];
\end_layout

\begin_layout Plain Layout

                cond <= word[24:21];
\end_layout

\begin_layout Plain Layout

                reg_a_addr <= word[20:16]; reg_b_addr <= word[15:11]; reg_c_addr
 <= word[10:6]; reg_d_addr <= word[5:1];
\end_layout

\begin_layout Plain Layout

                imm_action <= {1'b0, word[5:4]};
\end_layout

\begin_layout Plain Layout

                state1 <= opcode;
\end_layout

\begin_layout Plain Layout

                #1;
\end_layout

\begin_layout Plain Layout

                d_pcincr <= 1;
\end_layout

\begin_layout Plain Layout

                d_pass <= 1;
\end_layout

\begin_layout Plain Layout

                reg_fetch <= 1;
\end_layout

\begin_layout Plain Layout

            end
\end_layout

\begin_layout Plain Layout

            stage1 <= 1;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    always @(posedge stage1) begin
\end_layout

\begin_layout Plain Layout

            #0.1;
\end_layout

\begin_layout Plain Layout

            case(state1)
\end_layout

\begin_layout Plain Layout

                //logic
\end_layout

\begin_layout Plain Layout

                0: begin //nop
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 0; e_cond <= 0; e_write_flags <= 0; e_is_cond
 <= 0; //alu nop, not conditional, no flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b0; m_r2_op <= 4'b0; //memory clean nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 0; //register write nop
\end_layout

\begin_layout Plain Layout

                    r_read <= 0; //register read none
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                    imm_action <= 3'b000; //no imm in this insn
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                1: begin //or
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h0D; e_cond <= cond; e_write_flags <=
 4'hF; e_is_cond <= 1; //alu or, conditional, all flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 1; r_a1 <= reg_c_addr; // register write c to
 a1
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_r2_addr <= reg_b_addr; r_read
 <= 3; //register read both
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                2: begin //nor
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h10; e_cond <= cond; e_write_flags <=
 4'hF; e_is_cond <= 1; //alu nor, conditional, all flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 1; r_a1 <= reg_c_addr; // register write c to
 a1
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_r2_addr <= reg_b_addr; r_read
 <= 3; //register read both
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                3: begin //and
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h0C; e_cond <= cond; e_write_flags <=
 4'hF; e_is_cond <= 1; //alu and, conditional, all flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 1; r_a1 <= reg_c_addr; // register write c to
 a1
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_r2_addr <= reg_b_addr; r_read
 <= 3; //register read both
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                4: begin //nand
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h0F; e_cond <= cond; e_write_flags <=
 4'hF; e_is_cond <= 1; //alu nand, conditional, all flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 1; r_a1 <= reg_c_addr; // register write c to
 a1
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_r2_addr <= reg_b_addr; r_read
 <= 3; //register read both
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                5: begin //inv
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h0B; e_cond <= cond; e_write_flags <=
 4'hF; e_is_cond <= 1; //alu not, conditional, all flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 1; r_a1 <= reg_c_addr; // register write c to
 a1
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_read <= 1; //register read
 first
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                    imm_action[0] <= 0; //no imm for b in this insn
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                6: begin //xor
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h0E; e_cond <= cond; e_write_flags <=
 4'hF; e_is_cond <= 1; //alu xor, conditional, all flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 1; r_a1 <= reg_c_addr; // register write c to
 a1
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_r2_addr <= reg_b_addr; r_read
 <= 3; //register read both
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                7: begin //xnor
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h11; e_cond <= cond; e_write_flags <=
 4'hF; e_is_cond <= 1; //alu xnor, conditional, all flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 1; r_a1 <= reg_c_addr; // register write c to
 a1
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_r2_addr <= reg_b_addr; r_read
 <= 3; //register read both
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                //shifts
\end_layout

\begin_layout Plain Layout

                8: begin //lsl
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h06; e_cond <= cond; e_write_flags <=
 4'hF; e_is_cond <= 1; //alu shl, conditional, all flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 1; r_a1 <= reg_c_addr; // register write c to
 a1
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_r2_addr <= reg_b_addr; r_read
 <= 3; //register read both
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                9: begin //lsr
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h05; e_cond <= cond; e_write_flags <=
 4'hF; e_is_cond <= 1; //alu shr, conditional, all flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 1; r_a1 <= reg_c_addr; // register write c to
 a1
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_r2_addr <= reg_b_addr; r_read
 <= 3; //register read both
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                10: begin //asr
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h07; e_cond <= cond; e_write_flags <=
 4'hF; e_is_cond <= 1; //alu sar, conditional, all flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 1; r_a1 <= reg_c_addr; // register write c to
 a1
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_r2_addr <= reg_b_addr; r_read
 <= 3; //register read both
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                11: begin //asl
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h08; e_cond <= cond; e_write_flags <=
 4'hF; e_is_cond <= 1; //alu sal, conditional, all flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 1; r_a1 <= reg_c_addr; // register write c to
 a1
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_r2_addr <= reg_b_addr; r_read
 <= 3; //register read both
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                12: begin //csr
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h09; e_cond <= cond; e_write_flags <=
 4'hF; e_is_cond <= 1; //alu ror, conditional, all flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 1; r_a1 <= reg_c_addr; // register write c to
 a1
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_r2_addr <= reg_b_addr; r_read
 <= 3; //register read both
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                13: begin //csl
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h0A; e_cond <= cond; e_write_flags <=
 4'hF; e_is_cond <= 1; //alu rol, conditional, all flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 1; r_a1 <= reg_c_addr; // register write c to
 a1
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_r2_addr <= reg_b_addr; r_read
 <= 3; //register read both
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                //arithmetics
\end_layout

\begin_layout Plain Layout

                14: begin //add
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h01; e_cond <= cond; e_write_flags <=
 4'hF; e_is_cond <= 1; //alu add, conditional, all flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 1; r_a1 <= reg_c_addr; // register write c to
 a1
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_r2_addr <= reg_b_addr; r_read
 <= 3; //register read both
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                15: begin //sub
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h02; e_cond <= cond; e_write_flags <=
 4'hF; e_is_cond <= 1; //alu sub, conditional, all flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 1; r_a1 <= reg_c_addr; // register write c to
 a1
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_r2_addr <= reg_b_addr; r_read
 <= 3; //register read both
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                16: begin //mull
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h04; e_cond <= cond; e_write_flags <=
 4'hF; e_is_cond <= 1; //alu mul, conditional, all flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 1; r_a1 <= reg_c_addr; // register write c to
 a1
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_r2_addr <= reg_b_addr; r_read
 <= 3; //register read both
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                17: begin //mulh
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h04; e_cond <= cond; e_write_flags <=
 4'hF; e_is_cond <= 1; //alu mul, conditional, all flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 4; r_a1 <= reg_c_addr; // register write d to
 a1
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_r2_addr <= reg_b_addr; r_read
 <= 3; //register read both
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                18: begin //mul
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h04; e_cond <= cond; e_write_flags <=
 4'hF; e_is_cond <= 1; //alu mul, conditional, all flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 7; r_a1 <= reg_c_addr; r_a2 <= reg_d_addr; //
 register write c,d to a1,a2
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_r2_addr <= reg_b_addr; r_read
 <= 3; //register read both
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                    imm_action <= 3'b000; //no imm in this insn
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                19: begin //csg
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h03; e_cond <= cond; e_write_flags <=
 4'hF; e_is_cond <= 1; //alu cpl, conditional, all flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 1; r_a1 <= reg_c_addr; // register write c to
 a1
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_read <= 1; //register read
 first
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                    imm_action[0] <= 0; //no imm for b in this insn
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                20: begin //inc
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h01; e_cond <= cond; e_write_flags <=
 4'hF; e_is_cond <= 1; //alu add, conditional, all flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 1; r_a1 <= reg_c_addr; // register write c to
 a1
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_read <= 1; //register read
 first
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                    e_b <= 1; //force b operand to be 1
\end_layout

\begin_layout Plain Layout

                    imm_action[0] <= 0; //no imm for b in this insn
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                21: begin //dec
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h02; e_cond <= cond; e_write_flags <=
 4'hF; e_is_cond <= 1; //alu sub, conditional, all flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 1; r_a1 <= reg_c_addr; // register write c to
 a1
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_read <= 1; //register read
 first
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                    e_b <= 1; //force b operand to be 1
\end_layout

\begin_layout Plain Layout

                    imm_action[0] <= 0; //no imm for b in this insn
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                22: begin //cmp
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h02; e_cond <= cond; e_write_flags <=
 4'hF; e_is_cond <= 1; //alu sub, conditional, all flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 0; // register write nop
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_r2_addr <= reg_b_addr; r_read
 <= 3; //register read both
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                23: begin //cmn
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h01; e_cond <= cond; e_write_flags <=
 4'hF; e_is_cond <= 1; //alu add, conditional, all flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 0; // register write nop
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_r2_addr <= reg_b_addr; r_read
 <= 3; //register read both
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                24: begin //tst
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h0C; e_cond <= cond; e_write_flags <=
 4'hF; e_is_cond <= 1; //alu and, conditional, all flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 0; // register write nop
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_r2_addr <= reg_b_addr; r_read
 <= 3; //register read both
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                //branches
\end_layout

\begin_layout Plain Layout

                25: begin //br
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h00; e_cond <= cond; e_write_flags <=
 4'h0; e_is_cond <= 1; //alu nop, conditional, no flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 1; r_a1 <= 31; // register write to pc
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_read <= 1; //register read
 first
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                    imm_action[0] <= 0; //no imm for b in this insn
\end_layout

\begin_layout Plain Layout

                    //delay!
\end_layout

\begin_layout Plain Layout

                    //set_delay <= 1;
\end_layout

\begin_layout Plain Layout

                    fetch <= 0; d_pcincr <= 0;
\end_layout

\begin_layout Plain Layout

                    state1 <= 130;
\end_layout

\begin_layout Plain Layout

                    delay_counter <= 3;
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                26: begin //rbr
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h01; e_cond <= cond; e_write_flags <=
 4'h0; e_is_cond <= 1; //alu add, conditional, no flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 1; r_a1 <= 31; // register write to pc
\end_layout

\begin_layout Plain Layout

                    r_r2_addr <= reg_a_addr; r_r1_addr <= 31; r_read <=
 3; //register read both, first - pc
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                    imm_action[0] <= 0; //no imm for b in this insn
\end_layout

\begin_layout Plain Layout

                    //delay!
\end_layout

\begin_layout Plain Layout

                    //set_delay <= 1;
\end_layout

\begin_layout Plain Layout

                    fetch <= 0; d_pcincr <= 0;
\end_layout

\begin_layout Plain Layout

                    state1 <= 130;
\end_layout

\begin_layout Plain Layout

                    delay_counter <= 3;
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                27: begin //brl
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h00; e_cond <= cond; e_write_flags <=
 4'h0; e_is_cond <= 1; //alu nop, conditional, no flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 7; r_a1 <= 31; r_a2 <= 29; // register write
 a,b to pc,lr
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_r2_addr <= 31; r_read <=
 3; //register read both, second - pc
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                    imm_action[0] <= 0; //no imm for b in this insn
\end_layout

\begin_layout Plain Layout

                    //delay!
\end_layout

\begin_layout Plain Layout

                    //set_delay <= 1;
\end_layout

\begin_layout Plain Layout

                    fetch <= 0; d_pcincr <= 0;
\end_layout

\begin_layout Plain Layout

                    state1 <= 130;
\end_layout

\begin_layout Plain Layout

                    delay_counter <= 3;
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                /*27: begin //rbl, can't implement now (need hook in register_wb
)
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h01; e_cond <= cond; e_write_flags <=
 4'h0; e_is_cond <= 1; //alu add, conditional, no flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 1; r_a1 <= 31 // register write to pc
\end_layout

\begin_layout Plain Layout

                    r_r2_addr <= reg_a_addr; r_r1_addr <= 31; r_read <=
 2; //register read both, first - pc
\end_layout

\begin_layout Plain Layout

                    imm_action[0] <= 0; //no imm for b in this insn
\end_layout

\begin_layout Plain Layout

                    //delay!
\end_layout

\begin_layout Plain Layout

                end*/
\end_layout

\begin_layout Plain Layout

                28: begin //ret
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h00; e_cond <= cond; e_write_flags <=
 4'h0; e_is_cond <= 1; //alu nop, conditional, no flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 1; r_a1 <= 31; // register write to pc
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= 29; r_read <= 1; //register read first
 - lr
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                    imm_action <= 3'b000; //no imm in this insn
\end_layout

\begin_layout Plain Layout

                    //delay!
\end_layout

\begin_layout Plain Layout

                    //set_delay <= 1;
\end_layout

\begin_layout Plain Layout

                    fetch <= 0; d_pcincr <= 0;
\end_layout

\begin_layout Plain Layout

                    state1 <= 130;
\end_layout

\begin_layout Plain Layout

                    delay_counter <= 3;
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                29: begin //ldr
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h00; e_cond <= cond; e_write_flags <=
 4'h0; e_is_cond <= 1; //alu nop, conditional, no flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 2; m_r2_op <= 1; //memory read c from a1
\end_layout

\begin_layout Plain Layout

                    r_op <= 1; r_a1 <= reg_c_addr; // register write c to
 a1
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_read <= 1; //register read
 first
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 2'b01;//register read to m1, b
\end_layout

\begin_layout Plain Layout

                    imm_action[0] <= 0; //no imm for b in this insn
\end_layout

\begin_layout Plain Layout

                    imm_action[2] <= 1; //imm goes into m
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                30: begin //str
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h00; e_cond <= cond; e_write_flags <=
 4'h0; e_is_cond <= 1; //alu nop, conditional, no flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 1; m_r2_op <= 5; //memory write d to a1
\end_layout

\begin_layout Plain Layout

                    r_op <= 0; // register write nop
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_r2_addr <= reg_b_addr; r_read
 <= 3; //register read both
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 2'b01;//register read to m1, b
\end_layout

\begin_layout Plain Layout

                    imm_action[0] <= 0; //no imm for b in this insn
\end_layout

\begin_layout Plain Layout

                    imm_action[2] <= 1; //imm goes into m
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                //ldrc
\end_layout

\begin_layout Plain Layout

                //strc
\end_layout

\begin_layout Plain Layout

                //needs more elaborate management of operands (3, but have
 only 2, perhaps use imm ?
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                //push
\end_layout

\begin_layout Plain Layout

                //pop
\end_layout

\begin_layout Plain Layout

                //one of this needs advanced management in memory_op stage
\end_layout

\begin_layout Plain Layout

                //or make as in x86 - pop only decrements, not returning
 result
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                31: begin //in
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h00; e_cond <= cond; e_write_flags <=
 4'h0; e_is_cond <= 1; //alu nop, conditional, no flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1000; m_r2_op <= 4'b1; //sys read c from
 a1
\end_layout

\begin_layout Plain Layout

                    r_op <= 1; r_a1 <= reg_c_addr; // register write c to
 a1
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_read <= 1; //register read
 first
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 2'b01;//register read to m1, b
\end_layout

\begin_layout Plain Layout

                    imm_action[0] <= 0; //no imm for b in this insn
\end_layout

\begin_layout Plain Layout

                    imm_action[2] <= 1; //imm goes into m
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                32: begin //out
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h00; e_cond <= cond; e_write_flags <=
 4'h0; e_is_cond <= 1; //alu nop, conditional, no flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1011; //sys write d to
 a1
\end_layout

\begin_layout Plain Layout

                    r_op <= 0; // register write nop
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_r2_addr <= reg_b_addr; r_read
 <= 3; //register read both
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 2'b01;//register read to m1, b
\end_layout

\begin_layout Plain Layout

                    imm_action[0] <= 0; //no imm for b in this insn
\end_layout

\begin_layout Plain Layout

                    imm_action[2] <= 1; //imm goes into m
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                //ini
\end_layout

\begin_layout Plain Layout

                //outi
\end_layout

\begin_layout Plain Layout

                //needs more elaborate management of operands (3, but have
 only 2, perhaps use imm ?
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                33: begin //movs
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h00; e_cond <= cond; e_write_flags <=
 4'h0; e_is_cond <= 1; //alu nop, conditional, no flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 1; r_a1 <= reg_c_addr; // register write c to
 a1
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_read <= 1; //register read
 first
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                    imm_action[0] <= 0; //no imm for b in this insn
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                34: begin //mov
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h00; e_cond <= cond; e_write_flags <=
 4'h0; e_is_cond <= 1; //alu nop, conditional, all flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b1; m_r2_op <= 4'b1; //memory passthrough
 nop
\end_layout

\begin_layout Plain Layout

                    r_op <= 7; r_a1 <= reg_c_addr; r_a2 <= reg_d_addr; //
 register write c,d to a1,a2
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_r2_addr <= reg_b_addr; r_read
 <= 3; //register read both
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 0;//register read to a,b
\end_layout

\begin_layout Plain Layout

                    imm_action <= 3'b000; //no imm in this insn
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                /*28: begin //ldr
\end_layout

\begin_layout Plain Layout

                    e_alu_op <= 8'h00; e_cond <= cond; e_write_flags <=
 4'h0; e_is_cond <= 1; //alu nop, conditional, no flags
\end_layout

\begin_layout Plain Layout

                    m_r1_op <= 4'b0011; m_r2_op <= 4'b1; //memory read c
 from a2
\end_layout

\begin_layout Plain Layout

                    r_op <= 1; r_a1 <= reg_c_addr; // register write c to
 a1
\end_layout

\begin_layout Plain Layout

                    r_r1_addr <= reg_a_addr; r_r2_addr <= reg_b_addr; r_read
 <= 3; //register read both
\end_layout

\begin_layout Plain Layout

                    r_to_mem <= 2'b10;//register read to a,m2
\end_layout

\begin_layout Plain Layout

                end*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                128: begin //get first imm
\end_layout

\begin_layout Plain Layout

                    if(imm_action == 3'b001) e_b <= word;
\end_layout

\begin_layout Plain Layout

                    else if(imm_action == 3'b010 || imm_action == 3'b011)
 e_a <= word;
\end_layout

\begin_layout Plain Layout

                    else if(imm_action == 3'b110 || imm_action == 3'b111)
 m_a1 <= word;
\end_layout

\begin_layout Plain Layout

                    else if(imm_action == 3'b101) m_a2 <= word;
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                129: begin //get second imm
\end_layout

\begin_layout Plain Layout

                    if(imm_action == 3'b011) e_b <= word;
\end_layout

\begin_layout Plain Layout

                    else if(imm_action == 3'b111) m_a2 <= word;
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                130: begin //delay
\end_layout

\begin_layout Plain Layout

                    fetch <= 0; d_pass <= 0; d_pcincr <= 0;
\end_layout

\begin_layout Plain Layout

                    if(delay_counter > 0) delay_counter<=delay_counter-1;
\end_layout

\begin_layout Plain Layout

                    #0;
\end_layout

\begin_layout Plain Layout

                    if(delay_counter == 0) begin
\end_layout

\begin_layout Plain Layout

                        fetch <= 1; /*d_pass <= 1;*/ d_pcincr <= 1;
\end_layout

\begin_layout Plain Layout

                        state1 <= 0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                131: begin //hazard hold
\end_layout

\begin_layout Plain Layout

                    #0;
\end_layout

\begin_layout Plain Layout

                    if(!hazard) begin
\end_layout

\begin_layout Plain Layout

                       d_pcincr <= old_pcincr_hz;
\end_layout

\begin_layout Plain Layout

                       d_pass <= old_pass_hz;
\end_layout

\begin_layout Plain Layout

                       reg_fetch <= 1;
\end_layout

\begin_layout Plain Layout

                       fetch <= old_fetch_hz;
\end_layout

\begin_layout Plain Layout

                       state1 <= old_state1_hz;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                //132: begin //branch pipeline purge
\end_layout

\begin_layout Plain Layout

                default: begin
\end_layout

\begin_layout Plain Layout

                    fetch <= 1;
\end_layout

\begin_layout Plain Layout

                    state1 <= 0;
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

            endcase
\end_layout

\begin_layout Plain Layout

            #0;
\end_layout

\begin_layout Plain Layout

            if(set_delay) begin
\end_layout

\begin_layout Plain Layout

                fetch <= 0; d_pcincr <= 0;
\end_layout

\begin_layout Plain Layout

                state1 <= 130;
\end_layout

\begin_layout Plain Layout

                set_delay <= 0;
\end_layout

\begin_layout Plain Layout

            end
\end_layout

\begin_layout Plain Layout

            stage1 <= 0;
\end_layout

\begin_layout Plain Layout

            stage2 <= 1;
\end_layout

\begin_layout Plain Layout

            /*@(posedge stage2) begin
\end_layout

\begin_layout Plain Layout

            if(imm_action != 3'b100 && imm_action != 3'b000) begin //imm
 fetch procedure
\end_layout

\begin_layout Plain Layout

                if(state1 != 128 && state1 != 129) begin //just got insn
\end_layout

\begin_layout Plain Layout

                    if(imm_action[1]) begin //imm for r1
\end_layout

\begin_layout Plain Layout

                        r_read[0] <= 0; //don't read r1
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                    if(imm_action[0]) begin //imm for r2
\end_layout

\begin_layout Plain Layout

                        r_read[1] <= 0;  //don't read r2
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                    old_state1_imm <= state1; //save state
\end_layout

\begin_layout Plain Layout

                    old_pass_imm <= d_pass;
\end_layout

\begin_layout Plain Layout

                    old_fetch_imm <= fetch;
\end_layout

\begin_layout Plain Layout

                    old_pcincr_imm <= d_pcincr;
\end_layout

\begin_layout Plain Layout

                    d_pass <= 0; //don't issue insn
\end_layout

\begin_layout Plain Layout

                    fetch <= 0; //don't decode insn
\end_layout

\begin_layout Plain Layout

                    reg_fetch <= 0; //don't fetch regs
\end_layout

\begin_layout Plain Layout

                    d_pcincr <= 1; //increment pc
\end_layout

\begin_layout Plain Layout

                    state1 <= 128; //fetch first imm
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                else if(state1 == 128) begin //first imm fetched
\end_layout

\begin_layout Plain Layout

                    if(imm_action == 3'b011 || imm_action == 3'b111) begin
 //need to fetch second imm
\end_layout

\begin_layout Plain Layout

                        d_pass <= 0; //don't issue insn
\end_layout

\begin_layout Plain Layout

                        fetch <= 0; //don't decode insn
\end_layout

\begin_layout Plain Layout

                        reg_fetch <= 0; //don't fetch regs
\end_layout

\begin_layout Plain Layout

                        d_pcincr <= 1; //increment pc
\end_layout

\begin_layout Plain Layout

                        state1 <= 129; //fetch second imm
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                    else begin //don't need to fetch second imm
\end_layout

\begin_layout Plain Layout

                        state1 <= old_state1_imm; //restore state
\end_layout

\begin_layout Plain Layout

                        d_pass <= old_pass_imm; //restore issue
\end_layout

\begin_layout Plain Layout

                        fetch <= old_fetch_imm; //restore fetch
\end_layout

\begin_layout Plain Layout

                        d_pcincr <= old_pcincr_imm; //restore incr pc
\end_layout

\begin_layout Plain Layout

                        reg_fetch <= 1; //fetch regs
\end_layout

\begin_layout Plain Layout

                        imm_action <= 3'b000; //don't fetch imm
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                else if(state1 == 129) begin //second imm fetched
\end_layout

\begin_layout Plain Layout

                        state1 <= old_state1_imm; //restore state
\end_layout

\begin_layout Plain Layout

                        d_pass <= old_pass_imm; //restore issue
\end_layout

\begin_layout Plain Layout

                        fetch <= old_fetch_imm; //restore fetch
\end_layout

\begin_layout Plain Layout

                        d_pcincr <= old_pcincr_imm; //restore incr pc
\end_layout

\begin_layout Plain Layout

                        reg_fetch <= 1; //fetch regs
\end_layout

\begin_layout Plain Layout

                        imm_action <= 3'b000; //don't fetch imm
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

            end
\end_layout

\begin_layout Plain Layout

            #0;
\end_layout

\begin_layout Plain Layout

            if(hazard && reg_fetch) begin //hazard op
\end_layout

\begin_layout Plain Layout

                old_pcincr_hz <= d_pcincr;
\end_layout

\begin_layout Plain Layout

                old_pass_hz <= d_pass;
\end_layout

\begin_layout Plain Layout

                old_fetch_hz <= fetch;
\end_layout

\begin_layout Plain Layout

                old_state1_hz <= state1;
\end_layout

\begin_layout Plain Layout

                d_pcincr <= 0;
\end_layout

\begin_layout Plain Layout

                d_pass <= 0;
\end_layout

\begin_layout Plain Layout

                fetch <= 0;
\end_layout

\begin_layout Plain Layout

                reg_fetch <= 0;
\end_layout

\begin_layout Plain Layout

                state1 <= 131;
\end_layout

\begin_layout Plain Layout

            end
\end_layout

\begin_layout Plain Layout

            #0;
\end_layout

\begin_layout Plain Layout

            if(reg_fetch) begin //reg fetch procedure
\end_layout

\begin_layout Plain Layout

               if(r_read[0]) begin
\end_layout

\begin_layout Plain Layout

                   if(r_to_mem[0]) m_a1 <= r1;
\end_layout

\begin_layout Plain Layout

                   else e_a <= r1;
\end_layout

\begin_layout Plain Layout

               end
\end_layout

\begin_layout Plain Layout

               if(r_read[1]) begin
\end_layout

\begin_layout Plain Layout

                   if(r_to_mem[1]) m_a2 <= r2;
\end_layout

\begin_layout Plain Layout

                   else e_b <= r2;
\end_layout

\begin_layout Plain Layout

               end
\end_layout

\begin_layout Plain Layout

               reg_fetch <= 0;
\end_layout

\begin_layout Plain Layout

            end
\end_layout

\begin_layout Plain Layout

            stage2 <= 0;
\end_layout

\begin_layout Plain Layout

            end*/
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    always @(posedge stage2) begin
\end_layout

\begin_layout Plain Layout

        #0;
\end_layout

\begin_layout Plain Layout

            if(imm_action != 3'b100 && imm_action != 3'b000) begin //imm
 fetch procedure
\end_layout

\begin_layout Plain Layout

                if(state1 != 128 && state1 != 129) begin //just got insn
\end_layout

\begin_layout Plain Layout

                    if(imm_action[1]) begin //imm for r1
\end_layout

\begin_layout Plain Layout

                        r_read[0] <= 0; //don't read r1
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                    if(imm_action[0]) begin //imm for r2
\end_layout

\begin_layout Plain Layout

                        r_read[1] <= 0;  //don't read r2
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                    old_state1_imm <= state1; //save state
\end_layout

\begin_layout Plain Layout

                    old_pass_imm <= d_pass;
\end_layout

\begin_layout Plain Layout

                    old_fetch_imm <= fetch;
\end_layout

\begin_layout Plain Layout

                    old_pcincr_imm <= d_pcincr;
\end_layout

\begin_layout Plain Layout

                    d_pass <= 0; //don't issue insn
\end_layout

\begin_layout Plain Layout

                    fetch <= 0; //don't decode insn
\end_layout

\begin_layout Plain Layout

                    reg_fetch <= 0; //don't fetch regs
\end_layout

\begin_layout Plain Layout

                    d_pcincr <= 1; //increment pc
\end_layout

\begin_layout Plain Layout

                    state1 <= 128; //fetch first imm
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                else if(state1 == 128) begin //first imm fetched
\end_layout

\begin_layout Plain Layout

                    if(imm_action == 3'b011 || imm_action == 3'b111) begin
 //need to fetch second imm
\end_layout

\begin_layout Plain Layout

                        d_pass <= 0; //don't issue insn
\end_layout

\begin_layout Plain Layout

                        fetch <= 0; //don't decode insn
\end_layout

\begin_layout Plain Layout

                        reg_fetch <= 0; //don't fetch regs
\end_layout

\begin_layout Plain Layout

                        d_pcincr <= 1; //increment pc
\end_layout

\begin_layout Plain Layout

                        state1 <= 129; //fetch second imm
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                    else begin //don't need to fetch second imm
\end_layout

\begin_layout Plain Layout

                        state1 <= old_state1_imm; //restore state
\end_layout

\begin_layout Plain Layout

                        d_pass <= old_pass_imm; //restore issue
\end_layout

\begin_layout Plain Layout

                        fetch <= old_fetch_imm; //restore fetch
\end_layout

\begin_layout Plain Layout

                        d_pcincr <= old_pcincr_imm; //restore incr pc
\end_layout

\begin_layout Plain Layout

                        reg_fetch <= 1; //fetch regs
\end_layout

\begin_layout Plain Layout

                        imm_action <= 3'b000; //don't fetch imm
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

                else if(state1 == 129) begin //second imm fetched
\end_layout

\begin_layout Plain Layout

                        state1 <= old_state1_imm; //restore state
\end_layout

\begin_layout Plain Layout

                        d_pass <= old_pass_imm; //restore issue
\end_layout

\begin_layout Plain Layout

                        fetch <= old_fetch_imm; //restore fetch
\end_layout

\begin_layout Plain Layout

                        d_pcincr <= old_pcincr_imm; //restore incr pc
\end_layout

\begin_layout Plain Layout

                        reg_fetch <= 1; //fetch regs
\end_layout

\begin_layout Plain Layout

                        imm_action <= 3'b000; //don't fetch imm
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

            end
\end_layout

\begin_layout Plain Layout

            stage2 <= 0;
\end_layout

\begin_layout Plain Layout

            stage3 <= 1;
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    always @(posedge stage3) begin
\end_layout

\begin_layout Plain Layout

        #0;
\end_layout

\begin_layout Plain Layout

            if(hazard && reg_fetch) begin //hazard op
\end_layout

\begin_layout Plain Layout

                old_pcincr_hz <= d_pcincr;
\end_layout

\begin_layout Plain Layout

                old_pass_hz <= d_pass;
\end_layout

\begin_layout Plain Layout

                old_fetch_hz <= fetch;
\end_layout

\begin_layout Plain Layout

                old_state1_hz <= state1;
\end_layout

\begin_layout Plain Layout

                d_pcincr <= 0;
\end_layout

\begin_layout Plain Layout

                d_pass <= 0;
\end_layout

\begin_layout Plain Layout

                fetch <= 0;
\end_layout

\begin_layout Plain Layout

                reg_fetch <= 0;
\end_layout

\begin_layout Plain Layout

                state1 <= 131;
\end_layout

\begin_layout Plain Layout

            end
\end_layout

\begin_layout Plain Layout

            #0;
\end_layout

\begin_layout Plain Layout

            if(reg_fetch) begin //reg fetch procedure
\end_layout

\begin_layout Plain Layout

               if(r_read[0]) begin
\end_layout

\begin_layout Plain Layout

                   if(r_to_mem[0]) m_a1 <= r1;
\end_layout

\begin_layout Plain Layout

                   else e_a <= r1;
\end_layout

\begin_layout Plain Layout

               end
\end_layout

\begin_layout Plain Layout

               if(r_read[1]) begin
\end_layout

\begin_layout Plain Layout

                   if(r_to_mem[1]) m_a2 <= r2;
\end_layout

\begin_layout Plain Layout

                   else e_b <= r2;
\end_layout

\begin_layout Plain Layout

               end
\end_layout

\begin_layout Plain Layout

               reg_fetch <= 0;
\end_layout

\begin_layout Plain Layout

            end
\end_layout

\begin_layout Plain Layout

            stage3 <= 0;
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
memory_op.v
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Verilog,numbers=left,basicstyle={\scriptsize\rmfamily},breaklines=true,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

`timescale 1 ns / 100 ps
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module memory_op_stage_passthrough(q_a1, q_a2, q_op, q_proceed, a1, a2,
 op, proceed, clk, rst);
\end_layout

\begin_layout Plain Layout

    input [4:0] a1, a2; //(reg_wb)
\end_layout

\begin_layout Plain Layout

    input [3:0] op; //(reg_wb)
\end_layout

\begin_layout Plain Layout

    input proceed;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input clk, rst;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output reg [4:0] q_a1, q_a2; //(reg_wb)
\end_layout

\begin_layout Plain Layout

    output reg [3:0] q_op; //(reg_wb)
\end_layout

\begin_layout Plain Layout

    output reg q_proceed;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    always @(posedge clk or posedge rst) begin
\end_layout

\begin_layout Plain Layout

        if(rst) begin
\end_layout

\begin_layout Plain Layout

            q_a1 <= 5'b0; q_a2 <= 5'b0;
\end_layout

\begin_layout Plain Layout

            q_op <= 4'b0;
\end_layout

\begin_layout Plain Layout

            q_proceed <= 1'b0;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        else begin
\end_layout

\begin_layout Plain Layout

            q_a1 <= a1; q_a2 <= a2;
\end_layout

\begin_layout Plain Layout

            q_op <= op;
\end_layout

\begin_layout Plain Layout

            q_proceed <= proceed;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module memory_op( m1, m2, ram_w_addr, ram_r_addr, ram_w, ram_r, ram_w_line,
 sys_w_addr, sys_r_addr, sys_w, sys_r, sys_w_line, r1, r2, a1, a2, r1_op,
 r2_op, ram_r_line, sys_r_line, proceed, clk, rst);
\end_layout

\begin_layout Plain Layout

    input [31:0] r1, r2; //inputs
\end_layout

\begin_layout Plain Layout

    input [31:0] a1, a2; //memory addresses
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input [3:0] r1_op, r2_op; //operation codes
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input [31:0] ram_r_line, sys_r_line; // read lanes
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input proceed; //conditional code test result
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input clk, rst;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output wire [31:0] m1, m2; //outputs
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output reg [31:0] ram_w_addr, sys_w_addr; //write addresses
\end_layout

\begin_layout Plain Layout

    output reg [31:0] ram_r_addr, sys_r_addr; //read addresses
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output reg [31:0] ram_w_line, sys_w_line; //write lanes
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output reg ram_w, sys_w, ram_r, sys_r; //read/write signals
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [3:0] r1_op_inner, r2_op_inner;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign r1_op_inner = proceed ? r1_op : 4'b0;
\end_layout

\begin_layout Plain Layout

    assign r2_op_inner = proceed ? r2_op : 4'b0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    reg [31:0] r1_inner, r2_inner; //copies of inputs delayed by 1 clk,
 to cope with problem of mux delay, which don't allows inputs to descend
 pipeline
\end_layout

\begin_layout Plain Layout

    //procedural continuous assignments aren't stable in IcarusVerilog,
 so use explicit muxes
\end_layout

\begin_layout Plain Layout

    reg [2:0] m1_select, m2_select;
\end_layout

\begin_layout Plain Layout

    assign m1 = (m1_select == 0 ? 32'b0 : (m1_select == 1 ? r1_inner : (m1_selec
t == 2 ? r2_inner : (m1_select == 3 ? ram_r_line : (m1_select == 4 ? sys_r_line
 : 32'hAAAAAAAA)))));
\end_layout

\begin_layout Plain Layout

    assign m2 = (m2_select == 0 ? 32'b0 : (m2_select == 1 ? r1_inner : (m2_selec
t == 2 ? r2_inner : (m2_select == 3 ? ram_r_line : (m2_select == 4 ? sys_r_line
 : 32'hAAAAAAAA)))));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    always @(posedge clk or posedge rst) begin
\end_layout

\begin_layout Plain Layout

        if(rst) begin
\end_layout

\begin_layout Plain Layout

            ram_w_addr <= 32'b0; ram_r_addr <= 32'b0;
\end_layout

\begin_layout Plain Layout

            sys_w_addr <= 32'b0; sys_r_addr <= 32'b0;
\end_layout

\begin_layout Plain Layout

            ram_w_line <= 32'b0; sys_w_line <= 32'b0;
\end_layout

\begin_layout Plain Layout

            ram_w <= 1'b0; ram_r <= 1'b0; sys_r <= 1'b0; sys_w <= 1'b0;
\end_layout

\begin_layout Plain Layout

            m1_select <= 0; m2_select <= 0;
\end_layout

\begin_layout Plain Layout

            r1_inner <= 32'b0; r2_inner <= 32'b0;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        else begin
\end_layout

\begin_layout Plain Layout

            //ram_w <= 1'b0; ram_r <= 1'b0; sys_r <= 1'b0; sys_w <= 1'b0;
\end_layout

\begin_layout Plain Layout

            //#0;
\end_layout

\begin_layout Plain Layout

            ram_w <= 1'b0; ram_r <= 1'b0; sys_r <= 1'b0; sys_w <= 1'b0;
\end_layout

\begin_layout Plain Layout

            case(r1_op_inner)
\end_layout

\begin_layout Plain Layout

                0: begin //clean NOP
\end_layout

\begin_layout Plain Layout

                    m1_select <= 0; //force m1 = 32'b0;
\end_layout

\begin_layout Plain Layout

                    //ram_w <= 1'b0; ram_r <= 1'b0; sys_r <= 1'b0; sys_w
 <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                1: begin //passthrough NOP
\end_layout

\begin_layout Plain Layout

                    m1_select <= 1; //force m1 = r1;
\end_layout

\begin_layout Plain Layout

                    //ram_w <= 1'b0; ram_r <= 1'b0; sys_r <= 1'b0; sys_w
 <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                2: begin //load from memory address a1
\end_layout

\begin_layout Plain Layout

                    m1_select <= 3;  //force m1 = ram_r_line;
\end_layout

\begin_layout Plain Layout

                    ram_r_addr <= a1;
\end_layout

\begin_layout Plain Layout

                    ram_r <= 1'b1;
\end_layout

\begin_layout Plain Layout

                    //ram_w <= 1'b0; sys_r <= 1'b0; sys_w <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                3: begin //load from memory address a2
\end_layout

\begin_layout Plain Layout

                    m1_select <= 3;  //force m1 = ram_r_line;
\end_layout

\begin_layout Plain Layout

                    ram_r_addr <= a2;
\end_layout

\begin_layout Plain Layout

                    ram_r <= 1'b1;
\end_layout

\begin_layout Plain Layout

                    //ram_w <= 1'b0; sys_r <= 1'b0; sys_w <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                4: begin //load from memory address r2
\end_layout

\begin_layout Plain Layout

                    m1_select <= 3;  //force m1 = ram_r_line;
\end_layout

\begin_layout Plain Layout

                    ram_r_addr <= r2;
\end_layout

\begin_layout Plain Layout

                    ram_r <= 1'b1;
\end_layout

\begin_layout Plain Layout

                    //ram_w <= 1'b0; sys_r <= 1'b0; sys_w <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                5: begin //write to memory address a1
\end_layout

\begin_layout Plain Layout

                    m1_select <= 1; //force m1 = r1;
\end_layout

\begin_layout Plain Layout

                    ram_w_line <= r1;
\end_layout

\begin_layout Plain Layout

                    ram_w_addr <= a1;
\end_layout

\begin_layout Plain Layout

                    ram_w <= 1'b1;
\end_layout

\begin_layout Plain Layout

                    //ram_r <= 1'b0; sys_r <= 1'b0; sys_w <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                6: begin //write to memory address a2
\end_layout

\begin_layout Plain Layout

                    m1_select <= 1; //force m1 = r1;
\end_layout

\begin_layout Plain Layout

                    ram_w_line <= r1;
\end_layout

\begin_layout Plain Layout

                    ram_w_addr <= a2;
\end_layout

\begin_layout Plain Layout

                    ram_w <= 1'b1;
\end_layout

\begin_layout Plain Layout

                    //ram_r <= 1'b0; sys_r <= 1'b0; sys_w <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                7: begin //write to memory address r2
\end_layout

\begin_layout Plain Layout

                    m1_select <= 1; //force m1 = r1;
\end_layout

\begin_layout Plain Layout

                    ram_w_line <= r1;
\end_layout

\begin_layout Plain Layout

                    ram_w_addr <= r2;
\end_layout

\begin_layout Plain Layout

                    ram_w <= 1'b1;
\end_layout

\begin_layout Plain Layout

                    //ram_r <= 1'b0; sys_r <= 1'b0; sys_w <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                8: begin //load from sys address a1
\end_layout

\begin_layout Plain Layout

                    m1_select <= 4; //force m1 = sys_r_line;
\end_layout

\begin_layout Plain Layout

                    sys_r_addr <= a1;
\end_layout

\begin_layout Plain Layout

                    sys_r <= 1'b1;
\end_layout

\begin_layout Plain Layout

                    //ram_w <= 1'b0; ram_r <= 1'b0; sys_w <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                9: begin //load from sys address a2
\end_layout

\begin_layout Plain Layout

                    m1_select <= 4; //force m1 = sys_r_line;
\end_layout

\begin_layout Plain Layout

                    sys_r_addr <= a2;
\end_layout

\begin_layout Plain Layout

                    sys_r <= 1'b1;
\end_layout

\begin_layout Plain Layout

                    //ram_w <= 1'b0; ram_r <= 1'b0; sys_w <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                10: begin //load from sys address r2
\end_layout

\begin_layout Plain Layout

                    m1_select <= 4; //force m1 = sys_r_line;
\end_layout

\begin_layout Plain Layout

                    sys_r_addr <= r2;
\end_layout

\begin_layout Plain Layout

                    sys_r <= 1'b1;
\end_layout

\begin_layout Plain Layout

                    //ram_w <= 1'b0; ram_r <= 1'b0; sys_w <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                11: begin //write to sys address a1
\end_layout

\begin_layout Plain Layout

                    m1_select <= 1; //force m1 = r1;
\end_layout

\begin_layout Plain Layout

                    sys_w_line <= r1;
\end_layout

\begin_layout Plain Layout

                    sys_w_addr <= a1;
\end_layout

\begin_layout Plain Layout

                    sys_w <= 1'b1;
\end_layout

\begin_layout Plain Layout

                    //ram_w <= 1'b0; ram_r <= 1'b0; sys_r <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                12: begin //write to sys address a2
\end_layout

\begin_layout Plain Layout

                    m1_select <= 1; //force m1 = r1;
\end_layout

\begin_layout Plain Layout

                    sys_w_line <= r1;
\end_layout

\begin_layout Plain Layout

                    sys_w_addr <= a2;
\end_layout

\begin_layout Plain Layout

                    sys_w <= 1'b1;
\end_layout

\begin_layout Plain Layout

                    //ram_w <= 1'b0; ram_r <= 1'b0; sys_r <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                13: begin //write to sys address r2
\end_layout

\begin_layout Plain Layout

                    m1_select <= 1; //force m1 = r1;
\end_layout

\begin_layout Plain Layout

                    sys_w_line <= r1;
\end_layout

\begin_layout Plain Layout

                    sys_w_addr <= r2;
\end_layout

\begin_layout Plain Layout

                    sys_w <= 1'b1;
\end_layout

\begin_layout Plain Layout

                    //ram_w <= 1'b0; ram_r <= 1'b0; sys_r <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                14: begin //swap regs
\end_layout

\begin_layout Plain Layout

                    m1_select <= 2; //force m1 = r2;
\end_layout

\begin_layout Plain Layout

                   // ram_w <= 1'b0; ram_r <= 1'b0; sys_r <= 1'b0; sys_w
 <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

            endcase
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            case(r2_op_inner)
\end_layout

\begin_layout Plain Layout

                0: begin //clean NOP
\end_layout

\begin_layout Plain Layout

                    m2_select <= 0; //force m2 = 32'b0;
\end_layout

\begin_layout Plain Layout

                    //ram_w <= 1'b0; ram_r <= 1'b0; sys_r <= 1'b0; sys_w
 <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                1: begin //passthrough NOP
\end_layout

\begin_layout Plain Layout

                    m2_select <= 2; //force m2 = r2;
\end_layout

\begin_layout Plain Layout

                    //ram_w <= 1'b0; ram_r <= 1'b0; sys_r <= 1'b0; sys_w
 <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                2: begin //load from memory address a1
\end_layout

\begin_layout Plain Layout

                    m2_select <= 3; //force m2 = ram_r_line;
\end_layout

\begin_layout Plain Layout

                    ram_r_addr <= a1;
\end_layout

\begin_layout Plain Layout

                    ram_r <= 1'b1;
\end_layout

\begin_layout Plain Layout

                    //ram_w <= 1'b0; sys_r <= 1'b0; sys_w <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                3: begin //load from memory address a2
\end_layout

\begin_layout Plain Layout

                    m2_select <= 3; //force m2 = ram_r_line;
\end_layout

\begin_layout Plain Layout

                    ram_r_addr <= a2;
\end_layout

\begin_layout Plain Layout

                    ram_r <= 1'b1;
\end_layout

\begin_layout Plain Layout

                    //ram_w <= 1'b0; sys_r <= 1'b0; sys_w <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                4: begin //load from memory address r1
\end_layout

\begin_layout Plain Layout

                    m2_select <= 3; //force m2 = ram_r_line;
\end_layout

\begin_layout Plain Layout

                    ram_r_addr <= r1;
\end_layout

\begin_layout Plain Layout

                    ram_r <= 1'b1;
\end_layout

\begin_layout Plain Layout

                    //ram_w <= 1'b0; sys_r <= 1'b0; sys_w <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                5: begin //write to memory address a1
\end_layout

\begin_layout Plain Layout

                    m2_select <= 2; //force m2 = r2;
\end_layout

\begin_layout Plain Layout

                    ram_w_line <= r2;
\end_layout

\begin_layout Plain Layout

                    ram_w_addr <= a1;
\end_layout

\begin_layout Plain Layout

                    ram_w <= 1'b1;
\end_layout

\begin_layout Plain Layout

                    //ram_r <= 1'b0; sys_r <= 1'b0; sys_w <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                6: begin //write to memory address a2
\end_layout

\begin_layout Plain Layout

                    m2_select <= 2; //force m2 = r2;
\end_layout

\begin_layout Plain Layout

                    ram_w_line <= r2;
\end_layout

\begin_layout Plain Layout

                    ram_w_addr <= a2;
\end_layout

\begin_layout Plain Layout

                    ram_w <= 1'b1;
\end_layout

\begin_layout Plain Layout

                    //ram_r <= 1'b0; sys_r <= 1'b0; sys_w <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                7: begin //write to memory address r1
\end_layout

\begin_layout Plain Layout

                    m2_select <= 2; //force m2 = r2;
\end_layout

\begin_layout Plain Layout

                    ram_w_line <= r2;
\end_layout

\begin_layout Plain Layout

                    ram_w_addr <= r1;
\end_layout

\begin_layout Plain Layout

                    ram_w <= 1'b1;
\end_layout

\begin_layout Plain Layout

                    //ram_r <= 1'b0; sys_r <= 1'b0; sys_w <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                8: begin //load from sys address a1
\end_layout

\begin_layout Plain Layout

                    m2_select <= 4; //force m2 = sys_r_line;
\end_layout

\begin_layout Plain Layout

                    sys_r_addr <= a1;
\end_layout

\begin_layout Plain Layout

                    sys_r <= 1'b1;
\end_layout

\begin_layout Plain Layout

                    //ram_w <= 1'b0; ram_r <= 1'b0; sys_w <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                9: begin //load from sys address a2
\end_layout

\begin_layout Plain Layout

                    m2_select <= 4; //force m2 = sys_r_line;
\end_layout

\begin_layout Plain Layout

                    sys_r_addr <= a2;
\end_layout

\begin_layout Plain Layout

                    sys_r <= 1'b1;
\end_layout

\begin_layout Plain Layout

                    //ram_w <= 1'b0; ram_r <= 1'b0; sys_w <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                10: begin //load from sys address r1
\end_layout

\begin_layout Plain Layout

                    m2_select <= 4; //force m2 = sys_r_line;
\end_layout

\begin_layout Plain Layout

                    sys_r_addr <= r1;
\end_layout

\begin_layout Plain Layout

                    sys_r <= 1'b1;
\end_layout

\begin_layout Plain Layout

                    //ram_w <= 1'b0; ram_r <= 1'b0; sys_w <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                11: begin //write to sys address a1
\end_layout

\begin_layout Plain Layout

                    m2_select <= 2; //force m2 = r2;
\end_layout

\begin_layout Plain Layout

                    sys_w_line <= r2;
\end_layout

\begin_layout Plain Layout

                    sys_w_addr <= a1;
\end_layout

\begin_layout Plain Layout

                    sys_w <= 1'b1;
\end_layout

\begin_layout Plain Layout

                    //ram_w <= 1'b0; ram_r <= 1'b0; sys_r <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                12: begin //write to sys address a2
\end_layout

\begin_layout Plain Layout

                    m2_select <= 2; //force m2 = r2;
\end_layout

\begin_layout Plain Layout

                    sys_w_line <= r2;
\end_layout

\begin_layout Plain Layout

                    sys_w_addr <= a2;
\end_layout

\begin_layout Plain Layout

                    sys_w <= 1'b1;
\end_layout

\begin_layout Plain Layout

                    //ram_w <= 1'b0; ram_r <= 1'b0; sys_r <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                13: begin //write to sys address r1
\end_layout

\begin_layout Plain Layout

                    m2_select <= 2; //force m2 = r2;
\end_layout

\begin_layout Plain Layout

                    sys_w_line <= r2;
\end_layout

\begin_layout Plain Layout

                    sys_w_addr <= r1;
\end_layout

\begin_layout Plain Layout

                    sys_w <= 1'b1;
\end_layout

\begin_layout Plain Layout

                    //ram_w <= 1'b0; ram_r <= 1'b0; sys_r <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                14: begin //swap regs
\end_layout

\begin_layout Plain Layout

                    m2_select <= 1; //force m2 = r1;
\end_layout

\begin_layout Plain Layout

                    //ram_w <= 1'b0; ram_r <= 1'b0; sys_r <= 1'b0; sys_w
 <= 1'b0;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

            endcase
\end_layout

\begin_layout Plain Layout

            r1_inner <= r1;
\end_layout

\begin_layout Plain Layout

            r2_inner <= r2;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
pipeline_interface.v
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Verilog,numbers=left,basicstyle={\scriptsize\rmfamily},breaklines=true,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

`timescale 1 ns / 100 ps
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module pipeline_interface(
\end_layout

\begin_layout Plain Layout

    qe_a, qe_b, qe_alu_op, qe_is_cond, qe_cond, qe_write_flags, qe_swp,
 qm_a1, qm_a2, qm_r1_op, qm_r2_op, qr_a1, qr_a2, qr_op, qd_pcincr,
\end_layout

\begin_layout Plain Layout

    e_a, e_b, e_alu_op, e_is_cond, e_cond, e_write_flags, e_swp, m_a1, m_a2,
 m_r1_op, m_r2_op, r_a1, r_a2, r_op, d_pass, d_pcincr, clk, rst);
\end_layout

\begin_layout Plain Layout

    input [31:0] e_a, e_b;
\end_layout

\begin_layout Plain Layout

    input [7:0] e_alu_op;
\end_layout

\begin_layout Plain Layout

    input [3:0] e_cond;
\end_layout

\begin_layout Plain Layout

    input [3:0] e_write_flags;
\end_layout

\begin_layout Plain Layout

    input e_swp;
\end_layout

\begin_layout Plain Layout

    input e_is_cond;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input [31:0] m_a1, m_a2;
\end_layout

\begin_layout Plain Layout

    input [3:0] m_r1_op, m_r2_op;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input [4:0] r_a1, r_a2;
\end_layout

\begin_layout Plain Layout

    input [3:0] r_op;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input d_pass;
\end_layout

\begin_layout Plain Layout

    input d_pcincr;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input clk, rst;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output reg [31:0] qe_a, qe_b;
\end_layout

\begin_layout Plain Layout

    output reg [7:0] qe_alu_op;
\end_layout

\begin_layout Plain Layout

    output reg [3:0] qe_cond;
\end_layout

\begin_layout Plain Layout

    output reg [3:0] qe_write_flags;
\end_layout

\begin_layout Plain Layout

    output reg qe_swp;
\end_layout

\begin_layout Plain Layout

    output reg qe_is_cond;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output reg [31:0] qm_a1, qm_a2;
\end_layout

\begin_layout Plain Layout

    output reg [3:0] qm_r1_op, qm_r2_op;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output reg [4:0] qr_a1, qr_a2;
\end_layout

\begin_layout Plain Layout

    output reg [3:0] qr_op;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output reg qd_pcincr;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    reg test;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    initial begin
\end_layout

\begin_layout Plain Layout

        test <= 1'b0;
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

    always @(posedge clk or posedge rst) begin
\end_layout

\begin_layout Plain Layout

        if(rst) begin
\end_layout

\begin_layout Plain Layout

            qe_a = 31'b0; qe_b = 31'b0;
\end_layout

\begin_layout Plain Layout

            qe_alu_op = 8'b0; //NOP
\end_layout

\begin_layout Plain Layout

            qe_cond = 4'b0;
\end_layout

\begin_layout Plain Layout

            qe_write_flags = 4'b0;
\end_layout

\begin_layout Plain Layout

            qe_swp = 1'b0; qe_is_cond = 1'b0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            qm_a1 = 31'b0; qm_a2 = 31'b0;
\end_layout

\begin_layout Plain Layout

            qm_r1_op = 4'b0; qm_r2_op = 4'b0; //clean NOP
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            qr_a1 = 5'b0; qr_a2 = 5'b0;
\end_layout

\begin_layout Plain Layout

            qr_op = 4'b0; //NOP;
\end_layout

\begin_layout Plain Layout

            test = ~test;
\end_layout

\begin_layout Plain Layout

            qd_pcincr = 1'b1;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        else begin
\end_layout

\begin_layout Plain Layout

            `ifdef INTERFACE_STAGE_NO_DELAY
\end_layout

\begin_layout Plain Layout

                #3;
\end_layout

\begin_layout Plain Layout

            `endif
\end_layout

\begin_layout Plain Layout

            if(!d_pass) begin // insert clean NOP
\end_layout

\begin_layout Plain Layout

                qe_a = 31'b0; qe_b = 31'b0;
\end_layout

\begin_layout Plain Layout

                qe_alu_op = 8'b0; //NOP
\end_layout

\begin_layout Plain Layout

                qe_cond = 4'b0;
\end_layout

\begin_layout Plain Layout

                qe_write_flags = 4'b0;
\end_layout

\begin_layout Plain Layout

                qe_swp = 1'b0; qe_is_cond = 1'b0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                qm_a1 = 31'b0; qm_a2 = 31'b0;
\end_layout

\begin_layout Plain Layout

                qm_r1_op = 4'b0; qm_r2_op = 4'b0; //clean NOP
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                qr_a1 = 5'b0; qr_a2 = 5'b0;
\end_layout

\begin_layout Plain Layout

                qr_op = 4'b0; //NOP;
\end_layout

\begin_layout Plain Layout

                test <= ~test;
\end_layout

\begin_layout Plain Layout

            end
\end_layout

\begin_layout Plain Layout

            else begin //pass args & signals down to the pipeline
\end_layout

\begin_layout Plain Layout

                qe_a = e_a; qe_b = e_b;
\end_layout

\begin_layout Plain Layout

                qe_alu_op = e_alu_op;
\end_layout

\begin_layout Plain Layout

                qe_cond = e_cond;
\end_layout

\begin_layout Plain Layout

                qe_write_flags = e_write_flags;
\end_layout

\begin_layout Plain Layout

                qe_swp = e_swp; qe_is_cond = e_is_cond;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                qm_a1 = m_a1; qm_a2 = m_a2;
\end_layout

\begin_layout Plain Layout

                qm_r1_op = m_r1_op; qm_r2_op = m_r2_op;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                qr_a1 = r_a1; qr_a2 = r_a2;
\end_layout

\begin_layout Plain Layout

                qr_op = r_op;
\end_layout

\begin_layout Plain Layout

            end
\end_layout

\begin_layout Plain Layout

            qd_pcincr = d_pcincr;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
ram.v
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Verilog,numbers=left,basicstyle={\scriptsize\rmfamily},breaklines=true,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

`timescale 1 ns / 100 ps
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module ram(r_addr, w_addr, r_line, w_line, read, write, wrdy, rrdy, exc,
 clk);
\end_layout

\begin_layout Plain Layout

    input [31:0] r_addr;
\end_layout

\begin_layout Plain Layout

    input [31:0] w_addr;
\end_layout

\begin_layout Plain Layout

    input [31:0] w_line;
\end_layout

\begin_layout Plain Layout

    input        read;
\end_layout

\begin_layout Plain Layout

    input        write;
\end_layout

\begin_layout Plain Layout

    input        clk;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output [31:0] r_line;
\end_layout

\begin_layout Plain Layout

    reg    [31:0] r_line;
\end_layout

\begin_layout Plain Layout

    output        exc;
\end_layout

\begin_layout Plain Layout

    reg           exc;
\end_layout

\begin_layout Plain Layout

    output        wrdy, rrdy;
\end_layout

\begin_layout Plain Layout

    reg           wrdy, rrdy;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //memory
\end_layout

\begin_layout Plain Layout

    parameter mem_size = 1024; //4kb, 4b/w
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    reg [31:0] mem [mem_size:0];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    integer i;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /*initial begin
\end_layout

\begin_layout Plain Layout

        for(i = 0; i < mem_size; i=i+1) begin
\end_layout

\begin_layout Plain Layout

            mem[i] = 32'b0;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        r_line = 32'b0;
\end_layout

\begin_layout Plain Layout

        exc = 1'b0;
\end_layout

\begin_layout Plain Layout

        wrdy = 1'b0;
\end_layout

\begin_layout Plain Layout

        rrdy = 1'b0;
\end_layout

\begin_layout Plain Layout

    end*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    always @(posedge clk) begin
\end_layout

\begin_layout Plain Layout

        if(wrdy) wrdy <= 1'b0;
\end_layout

\begin_layout Plain Layout

        if(rrdy) rrdy <= 1'b0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        if(read & !rrdy ) begin
\end_layout

\begin_layout Plain Layout

            if(r_addr >= mem_size) begin
\end_layout

\begin_layout Plain Layout

                r_line <= 32'b0;
\end_layout

\begin_layout Plain Layout

                exc <= 1'b1;
\end_layout

\begin_layout Plain Layout

            end
\end_layout

\begin_layout Plain Layout

            else begin
\end_layout

\begin_layout Plain Layout

                r_line <= mem[r_addr];
\end_layout

\begin_layout Plain Layout

                rrdy <= 1'b1;
\end_layout

\begin_layout Plain Layout

                exc <= 1'b0;
\end_layout

\begin_layout Plain Layout

            end
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        else r_line <= 32'bz;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        if(write && !wrdy) begin
\end_layout

\begin_layout Plain Layout

            if(w_addr >= mem_size) exc <= 1'b1;
\end_layout

\begin_layout Plain Layout

            else begin
\end_layout

\begin_layout Plain Layout

                mem[w_addr] <= w_line;
\end_layout

\begin_layout Plain Layout

                wrdy <= 1'b1;
\end_layout

\begin_layout Plain Layout

                exc <= 1'b0;
\end_layout

\begin_layout Plain Layout

            end
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module emb_ram(r_addr, w_addr, r_line, w_line, read, write, exc, clk);
\end_layout

\begin_layout Plain Layout

    input [31:0] r_addr;
\end_layout

\begin_layout Plain Layout

    input [31:0] w_addr;
\end_layout

\begin_layout Plain Layout

    input [31:0] w_line;
\end_layout

\begin_layout Plain Layout

    input        read;
\end_layout

\begin_layout Plain Layout

    input        write;
\end_layout

\begin_layout Plain Layout

    input        clk;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output [31:0] r_line;
\end_layout

\begin_layout Plain Layout

    reg    [31:0] r_line;
\end_layout

\begin_layout Plain Layout

    output        exc;
\end_layout

\begin_layout Plain Layout

    reg           exc;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //memory
\end_layout

\begin_layout Plain Layout

    parameter mem_size = 1024; //4kb, 4b/w
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    reg [31:0] mem [mem_size:0];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    integer i;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /*initial begin
\end_layout

\begin_layout Plain Layout

        for(i = 0; i < mem_size; i=i+1) begin
\end_layout

\begin_layout Plain Layout

            mem[i] = 32'b0;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        r_line = 32'b0;
\end_layout

\begin_layout Plain Layout

        exc = 1'b0;
\end_layout

\begin_layout Plain Layout

    end*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     always @(posedge clk) begin //??????????
\end_layout

\begin_layout Plain Layout

        #1;
\end_layout

\begin_layout Plain Layout

        if(read) begin
\end_layout

\begin_layout Plain Layout

            if(r_addr >= mem_size) begin
\end_layout

\begin_layout Plain Layout

                r_line <= 32'b0;
\end_layout

\begin_layout Plain Layout

                exc <= 1'b1;
\end_layout

\begin_layout Plain Layout

            end
\end_layout

\begin_layout Plain Layout

            else begin
\end_layout

\begin_layout Plain Layout

                r_line <= mem[r_addr];
\end_layout

\begin_layout Plain Layout

                exc <= 1'b0;
\end_layout

\begin_layout Plain Layout

            end
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        else r_line <= 32'bz;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        if(write) begin
\end_layout

\begin_layout Plain Layout

            if(w_addr >= mem_size) exc <= 1'b1;
\end_layout

\begin_layout Plain Layout

            else begin
\end_layout

\begin_layout Plain Layout

                mem[w_addr] <= w_line;
\end_layout

\begin_layout Plain Layout

                exc <= 1'b0;
\end_layout

\begin_layout Plain Layout

            end
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
register_wb.v
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Verilog,numbers=left,basicstyle={\scriptsize\rmfamily},breaklines=true,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

`timescale 1 ns / 100 ps
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module register_wb( write, wr1, wr2, wa1, wa2, r1, r2, a1, a2, op, proceed,
 clk, rst);
\end_layout

\begin_layout Plain Layout

    input [31:0] r1, r2;
\end_layout

\begin_layout Plain Layout

    input [4:0] a1, a2;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input [3:0] op;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input proceed;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input clk, rst;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output reg [31:0] wr1, wr2;
\end_layout

\begin_layout Plain Layout

    output reg [4:0] wa1, wa2;
\end_layout

\begin_layout Plain Layout

    output reg [1:0] write;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [3:0] inner_op;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign inner_op = proceed ? op : 4'b0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    always @(posedge clk or posedge rst) begin
\end_layout

\begin_layout Plain Layout

        if(rst) begin
\end_layout

\begin_layout Plain Layout

            wr1 <= 32'b0; wr2 <= 32'b0;
\end_layout

\begin_layout Plain Layout

            wa1 <= 5'b0; wa2 <= 5'b0;
\end_layout

\begin_layout Plain Layout

            write <= 2'b00;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        else begin
\end_layout

\begin_layout Plain Layout

            write <= 2'b00;
\end_layout

\begin_layout Plain Layout

            case(inner_op)
\end_layout

\begin_layout Plain Layout

                0: write <= 2'b00; //NOP
\end_layout

\begin_layout Plain Layout

                1: begin //write r1 to addr a1
\end_layout

\begin_layout Plain Layout

                    wr1 <= r1;
\end_layout

\begin_layout Plain Layout

                    wa1 <= a1;
\end_layout

\begin_layout Plain Layout

                    write <= 2'b01;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                2: begin //write r1 to addr a2
\end_layout

\begin_layout Plain Layout

                    wr1 <= r1;
\end_layout

\begin_layout Plain Layout

                    wa1 <= a2;
\end_layout

\begin_layout Plain Layout

                    write <= 2'b01;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                3: begin //write r1 to addr r2
\end_layout

\begin_layout Plain Layout

                    wr1 <= r1;
\end_layout

\begin_layout Plain Layout

                    wa1 <= r2[4:0];
\end_layout

\begin_layout Plain Layout

                    write <= 2'b01;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                4: begin //write r2 to addr a1
\end_layout

\begin_layout Plain Layout

                    wr1 <= r2;
\end_layout

\begin_layout Plain Layout

                    wa1 <= a1;
\end_layout

\begin_layout Plain Layout

                    write <= 2'b01;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                5: begin //write r2 to addr a2
\end_layout

\begin_layout Plain Layout

                    wr1 <= r2;
\end_layout

\begin_layout Plain Layout

                    wa1 <= a2;
\end_layout

\begin_layout Plain Layout

                    write <= 2'b01;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                6: begin //write r2 to addr r1
\end_layout

\begin_layout Plain Layout

                    wr1 <= r2;
\end_layout

\begin_layout Plain Layout

                    wa1 <= r1[4:0];
\end_layout

\begin_layout Plain Layout

                    write <= 2'b01;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                7: begin //write r2, r1 to a2, a1
\end_layout

\begin_layout Plain Layout

                    wr1 <= r1; wr2 <= r2;
\end_layout

\begin_layout Plain Layout

                    wa1 <= a1; wa2 <= a2;
\end_layout

\begin_layout Plain Layout

                    write <= 2'b11;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                8: begin //write r1, r2 to a2, a1
\end_layout

\begin_layout Plain Layout

                    wr1 <= r1; wr2 <= r2;
\end_layout

\begin_layout Plain Layout

                    wa1 <= a2; wa2 <= a1;
\end_layout

\begin_layout Plain Layout

                    write <= 2'b11;
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

            endcase
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
regs.v
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Verilog,numbers=left,basicstyle={\scriptsize\rmfamily},breaklines=true,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

`timescale 1 ns / 100 ps
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module reg32_2x2_pc(rd0, rd1, ra0, ra1, wa0, wa1, wd0, wd1, read, write,
 clk, rst, lrout, spout, stout, pcout, stin, stwr, pcincr);
\end_layout

\begin_layout Plain Layout

    parameter addrsize = 5;
\end_layout

\begin_layout Plain Layout

    parameter regsnum = 32;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input [addrsize-1:0] ra0, ra1;
\end_layout

\begin_layout Plain Layout

    input [addrsize-1:0] wa0, wa1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input [31:0] wd0, wd1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input [1:0] read, write;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input clk, rst;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output wire [31:0] rd0, rd1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    reg [31:0] regs [regsnum-1:0];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output wire [31:0] lrout, spout, stout, pcout;
\end_layout

\begin_layout Plain Layout

    input [31:0] stin;
\end_layout

\begin_layout Plain Layout

    input stwr, pcincr;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign pcout = regs[31];
\end_layout

\begin_layout Plain Layout

    assign lrout = regs[29];
\end_layout

\begin_layout Plain Layout

    assign spout = regs[30];
\end_layout

\begin_layout Plain Layout

    assign stout = regs[28];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign rd0 = regs[ra0];
\end_layout

\begin_layout Plain Layout

    assign rd1 = regs[ra1];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    always @(posedge clk or posedge rst) begin
\end_layout

\begin_layout Plain Layout

        #1;
\end_layout

\begin_layout Plain Layout

        if(rst) begin
\end_layout

\begin_layout Plain Layout

            /*rd0 <= 0;
\end_layout

\begin_layout Plain Layout

            rd1 <= 0;*/
\end_layout

\begin_layout Plain Layout

            regs[0] <= 32'b0;
\end_layout

\begin_layout Plain Layout

            regs[28] <= 32'b0;
\end_layout

\begin_layout Plain Layout

            regs[29] <= 32'b0;
\end_layout

\begin_layout Plain Layout

            regs[30] <= 32'b0;
\end_layout

\begin_layout Plain Layout

            regs[31] <= 32'b0;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        else begin
\end_layout

\begin_layout Plain Layout

        //if(read[0]) rd0 <= regs[ra0];
\end_layout

\begin_layout Plain Layout

        //if(read[1]) rd1 <= regs[ra1];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            if(write[0]) regs[wa0] <= wd0;
\end_layout

\begin_layout Plain Layout

            if(write[1]) regs[wa1] <= wd1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            if(stwr) regs[28] <= stin;
\end_layout

\begin_layout Plain Layout

            if(pcincr) regs[31] <= regs[31] + 1;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
shift.v
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Verilog,numbers=left,basicstyle={\scriptsize\rmfamily},breaklines=true,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

`timescale 1 ns / 100 ps
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/*module fr(a, q);
\end_layout

\begin_layout Plain Layout

    input  [2:0] a;
\end_layout

\begin_layout Plain Layout

    output [2:0] q;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign q[0] = a[0];
\end_layout

\begin_layout Plain Layout

    assign q[2] = ((~a[0])&a[2])^(a[0]&a[1]);
\end_layout

\begin_layout Plain Layout

    assign q[1] = ((~a[0])&a[1])^(a[0]&a[2]);
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module fe(a, q);
\end_layout

\begin_layout Plain Layout

    input  [1:0] a;
\end_layout

\begin_layout Plain Layout

    output [1:0] q;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign q[0] = a[0];
\end_layout

\begin_layout Plain Layout

    assign q[1] = a[0]^a[1];
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module rev_shift_4(I, O, S);
\end_layout

\begin_layout Plain Layout

    input  [3:0] I;
\end_layout

\begin_layout Plain Layout

    input  [1:0] S;
\end_layout

\begin_layout Plain Layout

    output [3:0] O;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire wfe[7:0];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    fe fe0({I[0], 1'b0}, wfe[1:0]);
\end_layout

\begin_layout Plain Layout

    fe fe1({I[1], 1'b0}, wfe[3:2]);
\end_layout

\begin_layout Plain Layout

    fe fe2({I[2], 1'b0}, wfe[5:4]);
\end_layout

\begin_layout Plain Layout

    fe fe1({I[3], 1'b0}, wfe[7:6]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire grb0[3:0];
\end_layout

\begin_layout Plain Layout

    wire sgrb[3:0];
\end_layout

\begin_layout Plain Layout

    wire wfr[3:0];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    fr fr0({S[0],wfe[1:0]}, {sgrb[0], grb0[0], wfr[0]});
\end_layout

\begin_layout Plain Layout

    fr fr1({S[0],wfe[2:3]}, {sgrb[1], grb0[1], wfr[1]});
\end_layout

\begin_layout Plain Layout

    fr fr2({S[0],wfe[5:4]}, {sgrb[2], grb0[2], wfr[2]});
\end_layout

\begin_layout Plain Layout

    fr fr3({S[0],wfe[7:6]}, {sgrb[3], grb0[3], wfr[3]});
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire ssgrb[1:0];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    fr fr4({S[1],wfr[1:0]},{ssgrb[0], O[1:0]});
\end_layout

\begin_layout Plain Layout

    fr fr5({S[1],wfr[3:2]},{ssgrb[1], O[3:2]});
\end_layout

\begin_layout Plain Layout

endmodule*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module right_shift_rot_32(y, a, b, rotate, sra, sla);
\end_layout

\begin_layout Plain Layout

    input [31:0] a;
\end_layout

\begin_layout Plain Layout

    input [4:0] b;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output[31:0] y;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input rotate, sra, sla;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire sgnr = sra ? a[31] : 1'b0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//stage 1, b[4] - 16-bit shift/rot
\end_layout

\begin_layout Plain Layout

    wire [31:0] st1;
\end_layout

\begin_layout Plain Layout

    wire [15:0] r1;
\end_layout

\begin_layout Plain Layout

    //rot section
\end_layout

\begin_layout Plain Layout

    assign r1 = rotate ? a[15:0] : (sgnr ? 16'hffff : 16'h0);
\end_layout

\begin_layout Plain Layout

    //shift section
\end_layout

\begin_layout Plain Layout

    assign st1[31:16] = b[4] ? r1 : a[31:16];
\end_layout

\begin_layout Plain Layout

    assign st1[15:0] = b[4] ? a[31:16] : a[15:0];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//stage 2, b[3] - 8-bit shift/rot
\end_layout

\begin_layout Plain Layout

    wire [31:0] st2;
\end_layout

\begin_layout Plain Layout

    wire [7:0] r2;
\end_layout

\begin_layout Plain Layout

    //rot section
\end_layout

\begin_layout Plain Layout

    assign r2 = rotate ? st1[7:0] : (sgnr ? 8'hff : 8'h0);
\end_layout

\begin_layout Plain Layout

    //shift section
\end_layout

\begin_layout Plain Layout

    assign st2[31:24] = b[3] ? r2 : st1[31:24];
\end_layout

\begin_layout Plain Layout

    assign st2[23:0] = b[3] ? st1[31:8] : st1[23:0];
\end_layout

\begin_layout Plain Layout

//stage 3, b[2] - 4-bit shift/rot
\end_layout

\begin_layout Plain Layout

    wire [31:0] st3;
\end_layout

\begin_layout Plain Layout

    wire [3:0] r3;
\end_layout

\begin_layout Plain Layout

    //rot section
\end_layout

\begin_layout Plain Layout

    assign r3 = rotate ? st2[3:0] : (sgnr ? 4'hf : 4'h0);
\end_layout

\begin_layout Plain Layout

    //shift section
\end_layout

\begin_layout Plain Layout

    assign st3[31:28] = b[2] ? r3 : st2[31:28];
\end_layout

\begin_layout Plain Layout

    assign st3[27:0] = b[2] ? st2[31:4] : st2[27:0];
\end_layout

\begin_layout Plain Layout

//stage 4, b[1] - 2-bit shift/rot
\end_layout

\begin_layout Plain Layout

    wire [31:0] st4;
\end_layout

\begin_layout Plain Layout

    wire [1:0] r4;
\end_layout

\begin_layout Plain Layout

    //rot section
\end_layout

\begin_layout Plain Layout

    assign r4 = rotate ? st3[1:0] : (sgnr ? 2'b11 : 2'b00);
\end_layout

\begin_layout Plain Layout

    //shift section
\end_layout

\begin_layout Plain Layout

    assign st4[31:30] = b[1] ? r4 : st3[31:30];
\end_layout

\begin_layout Plain Layout

    assign st4[29:0] = b[1] ? st3[31:2] : st3[29:0];
\end_layout

\begin_layout Plain Layout

//stage 5, b[0] - 1-bit shift/rot
\end_layout

\begin_layout Plain Layout

    wire r5;
\end_layout

\begin_layout Plain Layout

    wire sgnl;
\end_layout

\begin_layout Plain Layout

    //rot section
\end_layout

\begin_layout Plain Layout

    assign r5 = rotate ? st4[0] : sgnr;
\end_layout

\begin_layout Plain Layout

    //shift section
\end_layout

\begin_layout Plain Layout

    assign y[31] = b[0] ? r5 : st4[31];
\end_layout

\begin_layout Plain Layout

    assign {y[30:1], sgnl} = b[0] ? st4[31:1] : st4[30:0];
\end_layout

\begin_layout Plain Layout

    assign y[0] = sla ? a[0] : sgnl;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module right_rot_32(y, a, b);
\end_layout

\begin_layout Plain Layout

    input [31:0] a;
\end_layout

\begin_layout Plain Layout

    input [4:0] b;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output [31:0] y;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//stage 1, b[4] - 16-bit rot
\end_layout

\begin_layout Plain Layout

    wire [31:0] st1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign st1[31:16] = b[4] ? a[15:0] : a[31:16];
\end_layout

\begin_layout Plain Layout

    assign st1[15:0] = b[4] ? a[31:16] : a[15:0];
\end_layout

\begin_layout Plain Layout

//stage 2, b[3] - 8-bit rot
\end_layout

\begin_layout Plain Layout

    wire [31:0] st2;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign st2[31:24] = b[3] ? st1[7:0] : st1[31:24];
\end_layout

\begin_layout Plain Layout

    assign st2[23:0] = b[3] ? st1[31:8] : st1[23:0];
\end_layout

\begin_layout Plain Layout

//stage 3, b[2] - 4-bit rot
\end_layout

\begin_layout Plain Layout

    wire [31:0] st3;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign st3[31:28] = b[2] ? st2[3:0] : st2[31:28];
\end_layout

\begin_layout Plain Layout

    assign st3[27:0] = b[2] ? st2[31:4] : st2[27:0];
\end_layout

\begin_layout Plain Layout

//stage 4, b[1] - 2-bit rot
\end_layout

\begin_layout Plain Layout

    wire [31:0] st4;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign st4[31:30] = b[1] ? st3[1:0] : st3[31:30];
\end_layout

\begin_layout Plain Layout

    assign st4[29:0] = b[1] ? st3[31:2] : st3[29:0];
\end_layout

\begin_layout Plain Layout

//stage 5, b[0] - 1-bit rot
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign y[31] = b[0] ? st4[0] : st4[31];
\end_layout

\begin_layout Plain Layout

    assign y[30:0] = b[0] ? st4[31:1] : st4[30:0];
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module drev_32(q, a, e);
\end_layout

\begin_layout Plain Layout

    input [31:0] a;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output [31:0] q;
\end_layout

\begin_layout Plain Layout

    input e;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    genvar i;
\end_layout

\begin_layout Plain Layout

    generate for(i = 0; i < 32; i = i + 1) begin : drev_mixer
\end_layout

\begin_layout Plain Layout

        assign q[i] = e ? a[31-i] : a[i];
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

    endgenerate
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module fmask_32(q, a);
\end_layout

\begin_layout Plain Layout

    input [4:0] a;
\end_layout

\begin_layout Plain Layout

    output [31:0] q;
\end_layout

\begin_layout Plain Layout

    reg [31:0] q;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    always @* begin
\end_layout

\begin_layout Plain Layout

        case(a)
\end_layout

\begin_layout Plain Layout

            5'h00: q = 32'b11111111111111111111111111111111;
\end_layout

\begin_layout Plain Layout

            5'h01: q = 32'b01111111111111111111111111111111;
\end_layout

\begin_layout Plain Layout

            5'h02: q = 32'b00111111111111111111111111111111;
\end_layout

\begin_layout Plain Layout

            5'h03: q = 32'b00011111111111111111111111111111;
\end_layout

\begin_layout Plain Layout

            5'h04: q = 32'b00001111111111111111111111111111;
\end_layout

\begin_layout Plain Layout

            5'h05: q = 32'b00000111111111111111111111111111;
\end_layout

\begin_layout Plain Layout

            5'h06: q = 32'b00000011111111111111111111111111;
\end_layout

\begin_layout Plain Layout

            5'h07: q = 32'b00000001111111111111111111111111;
\end_layout

\begin_layout Plain Layout

            5'h08: q = 32'b00000000111111111111111111111111;
\end_layout

\begin_layout Plain Layout

            5'h09: q = 32'b00000000011111111111111111111111;
\end_layout

\begin_layout Plain Layout

            5'h0A: q = 32'b00000000001111111111111111111111;
\end_layout

\begin_layout Plain Layout

            5'h0B: q = 32'b00000000000111111111111111111111;
\end_layout

\begin_layout Plain Layout

            5'h0C: q = 32'b00000000000011111111111111111111;
\end_layout

\begin_layout Plain Layout

            5'h0D: q = 32'b00000000000001111111111111111111;
\end_layout

\begin_layout Plain Layout

            5'h0E: q = 32'b00000000000000111111111111111111;
\end_layout

\begin_layout Plain Layout

            5'h0F: q = 32'b00000000000000011111111111111111;
\end_layout

\begin_layout Plain Layout

            5'h10: q = 32'b00000000000000001111111111111111;
\end_layout

\begin_layout Plain Layout

            5'h11: q = 32'b00000000000000000111111111111111;
\end_layout

\begin_layout Plain Layout

            5'h12: q = 32'b00000000000000000011111111111111;
\end_layout

\begin_layout Plain Layout

            5'h13: q = 32'b00000000000000000001111111111111;
\end_layout

\begin_layout Plain Layout

            5'h14: q = 32'b00000000000000000000111111111111;
\end_layout

\begin_layout Plain Layout

            5'h15: q = 32'b00000000000000000000011111111111;
\end_layout

\begin_layout Plain Layout

            5'h16: q = 32'b00000000000000000000001111111111;
\end_layout

\begin_layout Plain Layout

            5'h17: q = 32'b00000000000000000000000111111111;
\end_layout

\begin_layout Plain Layout

            5'h18: q = 32'b00000000000000000000000011111111;
\end_layout

\begin_layout Plain Layout

            5'h19: q = 32'b00000000000000000000000001111111;
\end_layout

\begin_layout Plain Layout

            5'h1A: q = 32'b00000000000000000000000000111111;
\end_layout

\begin_layout Plain Layout

            5'h1B: q = 32'b00000000000000000000000000011111;
\end_layout

\begin_layout Plain Layout

            5'h1C: q = 32'b00000000000000000000000000001111;
\end_layout

\begin_layout Plain Layout

            5'h1D: q = 32'b00000000000000000000000000000111;
\end_layout

\begin_layout Plain Layout

            5'h1E: q = 32'b00000000000000000000000000000011;
\end_layout

\begin_layout Plain Layout

            5'h1F: q = 32'b00000000000000000000000000000001;
\end_layout

\begin_layout Plain Layout

            default: q = 32'b00000000000000000000000000000000;
\end_layout

\begin_layout Plain Layout

        endcase
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module ovf_32(q, a, f, sla);
\end_layout

\begin_layout Plain Layout

    input [31:0] f;
\end_layout

\begin_layout Plain Layout

    input [31:0] a;
\end_layout

\begin_layout Plain Layout

    input sla;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output q;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [30:0] aexp = a[31] ? 31'h7FFFFFFF : 31'h00000000;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire w1 = |((aexp^a[30:0])&(~(f[31:1])));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign q = sla&w1;
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module zmask_32(q, a, sla);
\end_layout

\begin_layout Plain Layout

    input [31:0] a;
\end_layout

\begin_layout Plain Layout

    input sla;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output [31:0] q;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign q[0] = sla | a[31];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    genvar i;
\end_layout

\begin_layout Plain Layout

    generate for(i = 1; i < 32; i = i + 1) begin : zmask_mixer
\end_layout

\begin_layout Plain Layout

        assign q[i] = sla ? a[32-i] : a[31-i];
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

    endgenerate
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module tblock_32(q, a, sgn, p, sla, sra);
\end_layout

\begin_layout Plain Layout

    input [31:0] a;
\end_layout

\begin_layout Plain Layout

    input [31:0] p;
\end_layout

\begin_layout Plain Layout

    input sgn, sla, sra;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output [31:0] q;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [30:0] s = (sra&sgn) ? 31'h7FFFFFFF : 31'h00000000;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign q[0] = a[0]&(~sla) | sla&sgn;
\end_layout

\begin_layout Plain Layout

    assign q[31:1] = a[31:1]&p[31:1] | s&(~p[31:1]);
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module bshift_32(q, ov, z, a, b, rotate, left, arith);
\end_layout

\begin_layout Plain Layout

    input [31:0] a;
\end_layout

\begin_layout Plain Layout

    input[4:0] b;
\end_layout

\begin_layout Plain Layout

    input rotate, left, arith;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output [31:0] q;
\end_layout

\begin_layout Plain Layout

    output ov, z;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] am;
\end_layout

\begin_layout Plain Layout

    drev_32 dr0(am, a, left);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] ym;
\end_layout

\begin_layout Plain Layout

    right_rot_32 rr0(ym, am, b);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire sra = (~rotate)&(~left)&arith;
\end_layout

\begin_layout Plain Layout

    wire sla = (~rotate)&(left)&arith;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire[31:0] f;
\end_layout

\begin_layout Plain Layout

    fmask_32 f0(f, b);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] p;
\end_layout

\begin_layout Plain Layout

    assign p = rotate ? 32'hFFFFFFFF : f;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] t;
\end_layout

\begin_layout Plain Layout

    tblock_32 t0(t, ym, a[31], p, sla, sra);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    drev_32 dr1(q, t, left);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] zm;
\end_layout

\begin_layout Plain Layout

    zmask_32 z0(zm, p, sla);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign z = ~|(zm&am);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    ovf_32 ov0(ov, a, f, sla);
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
test_periph_assembly.v
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Verilog,numbers=left,basicstyle={\scriptsize\rmfamily},breaklines=true,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

`timescale 1 ns / 100 ps
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

`include "gpio_mux.v"
\end_layout

\begin_layout Plain Layout

`include "gpio.v"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module test_periph_assembly(pins, sys_w_addr, sys_r_addr, sys_w_line, sys_r_line
, sys_w, sys_r, rst, clk);
\end_layout

\begin_layout Plain Layout

    inout [127:0] pins; //our system will have 128 pins
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //peripheral bus
\end_layout

\begin_layout Plain Layout

    input [31:0] sys_w_addr;
\end_layout

\begin_layout Plain Layout

    input [31:0] sys_r_addr;
\end_layout

\begin_layout Plain Layout

    input [31:0] sys_w_line;
\end_layout

\begin_layout Plain Layout

    output wire [31:0] sys_r_line;
\end_layout

\begin_layout Plain Layout

    input sys_w;
\end_layout

\begin_layout Plain Layout

    input sys_r;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //generic
\end_layout

\begin_layout Plain Layout

    input clk;
\end_layout

\begin_layout Plain Layout

    input rst;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /*devices registry
\end_layout

\begin_layout Plain Layout

     * 1.
 address
\end_layout

\begin_layout Plain Layout

     *  00000 - 00001 - not assigned (guard band) (0x00 - 0x01)
\end_layout

\begin_layout Plain Layout

     *  00010 - 00011 - gpio_mux pins 31:0 (0x02 - 0x03)
\end_layout

\begin_layout Plain Layout

     *  00100 - 00101 - gpio_mux pins 63:32 (0x04 - 0x05)
\end_layout

\begin_layout Plain Layout

     *  00110 - 00111 - gpio_mux pins 95:64 (0x06 - 0x07)
\end_layout

\begin_layout Plain Layout

     *  01000 - 01001 - gpio_mux pins 127:96 (0x08 - 0x09)
\end_layout

\begin_layout Plain Layout

     *  01010 - 01011 - gpio chip 1 (31:0) (0x0A - 0x0B)
\end_layout

\begin_layout Plain Layout

     *  01100 - 01101 - gpio chip 2 (63:32) (0x0C - 0x0D)
\end_layout

\begin_layout Plain Layout

     *  01110 - 01111 - gpio chip 3 (95:64) (0x0E - 0x0F)
\end_layout

\begin_layout Plain Layout

     *  10000 - 10001 - gpio chip 4 (127:96) (0x10 - 0x11)
\end_layout

\begin_layout Plain Layout

     * ---------------------------------------------
\end_layout

\begin_layout Plain Layout

     * 2.
 pins
\end_layout

\begin_layout Plain Layout

     *  all pins have gpio chip as function 0
\end_layout

\begin_layout Plain Layout

     * ---------------------------------------------
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] g0_out, g1_out, g2_out, g3_out;
\end_layout

\begin_layout Plain Layout

    wire [31:0] g0_in, g1_in, g2_in, g3_in;
\end_layout

\begin_layout Plain Layout

    wire [31:0] g0_dir, g1_dir, g2_dir, g3_dir;
\end_layout

\begin_layout Plain Layout

    gpio chip0(g0_out, g0_in, g0_dir, 32'hA, sys_w_addr, sys_r_addr, sys_w_line,
 sys_r_line, sys_w, sys_r, rst, clk);
\end_layout

\begin_layout Plain Layout

    gpio chip1(g1_out, g1_in, g1_dir, 32'hC, sys_w_addr, sys_r_addr, sys_w_line,
 sys_r_line, sys_w, sys_r, rst, clk);
\end_layout

\begin_layout Plain Layout

    gpio chip2(g2_out, g2_in, g2_dir, 32'hE, sys_w_addr, sys_r_addr, sys_w_line,
 sys_r_line, sys_w, sys_r, rst, clk);
\end_layout

\begin_layout Plain Layout

    gpio chip3(g3_out, g3_in, g3_dir, 32'h10, sys_w_addr, sys_r_addr, sys_w_line
, sys_r_line, sys_w, sys_r, rst, clk);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //here comes all other peripherals
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] mx0_f0_out, mx0_f1_out, mx0_f2_out, mx0_f3_out;
\end_layout

\begin_layout Plain Layout

    wire [31:0] mx1_f0_out, mx1_f1_out, mx1_f2_out, mx1_f3_out;
\end_layout

\begin_layout Plain Layout

    wire [31:0] mx2_f0_out, mx2_f1_out, mx2_f2_out, mx2_f3_out;
\end_layout

\begin_layout Plain Layout

    wire [31:0] mx3_f0_out, mx3_f1_out, mx3_f2_out, mx3_f3_out;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] mx0_f0_in, mx0_f1_in, mx0_f2_in, mx0_f3_in;
\end_layout

\begin_layout Plain Layout

    wire [31:0] mx1_f0_in, mx1_f1_in, mx1_f2_in, mx1_f3_in;
\end_layout

\begin_layout Plain Layout

    wire [31:0] mx2_f0_in, mx2_f1_in, mx2_f2_in, mx2_f3_in;
\end_layout

\begin_layout Plain Layout

    wire [31:0] mx3_f0_in, mx3_f1_in, mx3_f2_in, mx3_f3_in;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] mx0_f0_dir, mx0_f1_dir, mx0_f2_dir, mx0_f3_dir;
\end_layout

\begin_layout Plain Layout

    wire [31:0] mx1_f0_dir, mx1_f1_dir, mx1_f2_dir, mx1_f3_dir;
\end_layout

\begin_layout Plain Layout

    wire [31:0] mx2_f0_dir, mx2_f1_dir, mx2_f2_dir, mx2_f3_dir;
\end_layout

\begin_layout Plain Layout

    wire [31:0] mx3_f0_dir, mx3_f1_dir, mx3_f2_dir, mx3_f3_dir;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    gpio_mux mx0(pins[31:0], mx0_f0_in, mx0_f1_in, mx0_f2_in, mx0_f3_in,
 mx0_f0_out, mx0_f1_out, mx0_f2_out, mx0_f3_out, mx0_f0_dir, mx0_f1_dir,
 mx0_f2_dir, mx0_f3_dir, 32'h2, sys_w_addr, sys_r_addr, sys_w_line, sys_r_line,
 sys_w, sys_r, rst, clk);
\end_layout

\begin_layout Plain Layout

    gpio_mux mx1(pins[63:32], mx1_f0_in, mx1_f1_in, mx1_f2_in, mx1_f3_in,
 mx1_f0_out, mx1_f1_out, mx1_f2_out, mx1_f3_out, mx1_f0_dir, mx1_f1_dir,
 mx1_f2_dir, mx1_f3_dir, 32'h4, sys_w_addr, sys_r_addr, sys_w_line, sys_r_line,
 sys_w, sys_r, rst, clk);
\end_layout

\begin_layout Plain Layout

    gpio_mux mx2(pins[95:64], mx2_f0_in, mx2_f1_in, mx2_f2_in, mx2_f3_in,
 mx2_f0_out, mx2_f1_out, mx2_f2_out, mx2_f3_out, mx2_f0_dir, mx2_f1_dir,
 mx2_f2_dir, mx2_f3_dir, 32'h6, sys_w_addr, sys_r_addr, sys_w_line, sys_r_line,
 sys_w, sys_r, rst, clk);
\end_layout

\begin_layout Plain Layout

    gpio_mux mx3(pins[127:96], mx3_f0_in, mx3_f1_in, mx3_f2_in, mx3_f3_in,
 mx3_f0_out, mx3_f1_out, mx3_f2_out, mx3_f3_out, mx3_f0_dir, mx3_f1_dir,
 mx3_f2_dir, mx3_f3_dir, 32'h8, sys_w_addr, sys_r_addr, sys_w_line, sys_r_line,
 sys_w, sys_r, rst, clk);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //here comes function assignments
\end_layout

\begin_layout Plain Layout

    assign g0_in = mx0_f0_in, mx0_f0_out = g0_out, mx0_f0_dir = g0_dir;
\end_layout

\begin_layout Plain Layout

    assign g1_in = mx1_f0_in, mx1_f0_out = g1_out, mx1_f0_dir = g1_dir;
\end_layout

\begin_layout Plain Layout

    assign g2_in = mx2_f0_in, mx2_f0_out = g2_out, mx2_f0_dir = g2_dir;
\end_layout

\begin_layout Plain Layout

    assign g3_in = mx3_f0_in, mx3_f0_out = g3_out, mx3_f0_dir = g3_dir;
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
test_pipeline_assembly.v
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Verilog,numbers=left,basicstyle={\scriptsize\rmfamily},breaklines=true,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

`timescale 1 ns / 100 ps
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

`include "execute.v"
\end_layout

\begin_layout Plain Layout

`include "memory_op.v"
\end_layout

\begin_layout Plain Layout

`include "register_wb.v"
\end_layout

\begin_layout Plain Layout

`include "pipeline_interface.v"
\end_layout

\begin_layout Plain Layout

`include "insn_decoder.v"
\end_layout

\begin_layout Plain Layout

`include "regs.v"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/*module test_pipeline_assembly(e_a, e_b, e_alu_op, e_is_cond, e_cond, e_write_f
lags, e_swp, m_a1, m_a2, m_r1_op, m_r2_op, r_a1, r_a2, r_op, pass, pcincr,
 clk, rst);
\end_layout

\begin_layout Plain Layout

    input [31:0] e_a, e_b;
\end_layout

\begin_layout Plain Layout

    input [4:0] e_ra1, e_ra2;
\end_layout

\begin_layout Plain Layout

    input [3:0] e_rop;
\end_layout

\begin_layout Plain Layout

    input [7:0] e_alu_op;
\end_layout

\begin_layout Plain Layout

    input [3:0] e_cond;
\end_layout

\begin_layout Plain Layout

    input [3:0] e_write_flags;
\end_layout

\begin_layout Plain Layout

    input e_swp;
\end_layout

\begin_layout Plain Layout

    input e_is_cond;
\end_layout

\begin_layout Plain Layout

    input [31:0] m_a1, m_a2;
\end_layout

\begin_layout Plain Layout

    input [3:0] m_r1_op, m_r2_op;
\end_layout

\begin_layout Plain Layout

    input [4:0] r_a1, r_a2;
\end_layout

\begin_layout Plain Layout

    input [3:0] r_op;
\end_layout

\begin_layout Plain Layout

    input pass;
\end_layout

\begin_layout Plain Layout

    input pcincr;*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// BEWARE:
\end_layout

\begin_layout Plain Layout

// general rule for continuous assignment statements
\end_layout

\begin_layout Plain Layout

// you can use continuous assignment in instantiation (e.g.
 wire a = b;) only if a - input and b - output
\end_layout

\begin_layout Plain Layout

// if we got reverse situation, we must provide good continuous assignment
 below ( assign b = a )
\end_layout

\begin_layout Plain Layout

// "continuous assignment is not bidirectional; it have dataflow directed
 from rvalue to lvalue"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module test_pipeline_assembly(ram_w_addr, ram_r_addr, ram_w_line, ram_read,
 ram_write, sys_w_addr, sys_r_addr, sys_w_line, sys_read, sys_write, lr,
 sp, pc, st,  word, ram_r_line, sys_r_line, clk, rst);
\end_layout

\begin_layout Plain Layout

    input [31:0] word;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    input clk, rst;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output wire [31:0] ram_w_addr, ram_r_addr;
\end_layout

\begin_layout Plain Layout

    output wire [31:0] ram_w_line;
\end_layout

\begin_layout Plain Layout

    input  [31:0] ram_r_line;
\end_layout

\begin_layout Plain Layout

    output wire ram_read, ram_write;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output wire [31:0] sys_w_addr, sys_r_addr;
\end_layout

\begin_layout Plain Layout

    output wire [31:0] sys_w_line;
\end_layout

\begin_layout Plain Layout

    input  [31:0] sys_r_line;
\end_layout

\begin_layout Plain Layout

    output wire sys_read, sys_write;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output wire [31:0] lr, sp, pc, st;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /*wire [31:0] ram_w_addr, ram_r_addr;
\end_layout

\begin_layout Plain Layout

    wire [31:0] ram_w_line, ram_r_line;
\end_layout

\begin_layout Plain Layout

    wire ram_read, ram_write, ram_exception;
\end_layout

\begin_layout Plain Layout

    emb_ram ram0(.r_addr = ram_r_addr, .w_addr = ram_w_addr, .r_line = ram_r_line,
 .w_line = ram_w_line, .read = ram_read, .write = ram_write, .exc = ram_exception,
 .clk = clk);*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] reg_a, reg_b, reg_c, reg_d; //input
\end_layout

\begin_layout Plain Layout

    wire [4:0] reg_a_a, reg_a_b, reg_a_c, reg_a_d; //input
\end_layout

\begin_layout Plain Layout

    wire [1:0] reg_read, reg_write; //input
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] reg_lr, reg_sp, reg_pc; //output
\end_layout

\begin_layout Plain Layout

    wire [31:0] reg_stin, reg_stout; //input, output
\end_layout

\begin_layout Plain Layout

    wire reg_stwr; //input
\end_layout

\begin_layout Plain Layout

    wire reg_pcincr; //input
\end_layout

\begin_layout Plain Layout

    reg32_2x2_pc rf0(reg_a, reg_b, reg_a_a, reg_a_b, reg_a_c, reg_a_d, 
 reg_c,  reg_d, reg_read, reg_write, clk, rst,  reg_lr,  reg_sp, reg_stout,
 reg_pc, reg_stin, reg_stwr, reg_pcincr);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] e_a, e_b; //output
\end_layout

\begin_layout Plain Layout

    wire [7:0] e_alu_op; //output
\end_layout

\begin_layout Plain Layout

    wire [3:0] e_cond; //output
\end_layout

\begin_layout Plain Layout

    wire [3:0] e_write_flags; //output
\end_layout

\begin_layout Plain Layout

    wire e_swp; //output
\end_layout

\begin_layout Plain Layout

    wire e_is_cond; //output
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] m_a1, m_a2; //output
\end_layout

\begin_layout Plain Layout

    wire [3:0] m_r1_op, m_r2_op; //output
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [4:0] r_a1, r_a2; //output
\end_layout

\begin_layout Plain Layout

    wire [3:0] r_op; //output
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire d_pass; //output
\end_layout

\begin_layout Plain Layout

    wire d_pcincr; //output
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [4:0] r_r1_a, r_r2_a; //output
\end_layout

\begin_layout Plain Layout

    assign reg_a_a = r_r1_a, reg_a_b = r_r2_a;
\end_layout

\begin_layout Plain Layout

    wire [1:0] r_read; //output
\end_layout

\begin_layout Plain Layout

    assign reg_read = r_read;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] d_word = word; //input
\end_layout

\begin_layout Plain Layout

    wire [31:0] d_r1 = reg_a, d_r2 = reg_b; //input
\end_layout

\begin_layout Plain Layout

    wire d_hazard; //input
\end_layout

\begin_layout Plain Layout

    insn_decoder dec0(e_a, e_b, e_alu_op, e_is_cond, e_cond, e_write_flags,
 e_swp, m_a1, m_a2, m_r1_op, m_r2_op, r_a1, r_a2, r_op, d_pass, d_pcincr,
 r_r1_a, r_r2_a, r_read, d_word, d_r1, d_r2, d_hazard, rst, clk);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] pi_e_a, pi_e_b; //output
\end_layout

\begin_layout Plain Layout

    wire [7:0] pi_e_alu_op; //output
\end_layout

\begin_layout Plain Layout

    wire [3:0] pi_e_cond; //output
\end_layout

\begin_layout Plain Layout

    wire [3:0] pi_e_write_flags; //output
\end_layout

\begin_layout Plain Layout

    wire pi_e_swp; //output
\end_layout

\begin_layout Plain Layout

    wire pi_e_is_cond; //output
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] pi_m_a1, pi_m_a2; //output
\end_layout

\begin_layout Plain Layout

    wire [3:0] pi_m_r1_op, pi_m_r2_op; //output
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [4:0] pi_r_a1, pi_r_a2; //output
\end_layout

\begin_layout Plain Layout

    wire [3:0] pi_r_op; //output
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire pi_d_pcincr; //output
\end_layout

\begin_layout Plain Layout

    assign reg_pcincr = pi_d_pcincr;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    pipeline_interface pi0(
\end_layout

\begin_layout Plain Layout

    pi_e_a, pi_e_b, pi_e_alu_op, pi_e_is_cond, pi_e_cond, pi_e_write_flags,
 pi_e_swp, pi_m_a1, pi_m_a2, pi_m_r1_op, pi_m_r2_op, pi_r_a1, pi_r_a2, pi_r_op,
 pi_d_pcincr,
\end_layout

\begin_layout Plain Layout

    e_a, e_b, e_alu_op, e_is_cond, e_cond, e_write_flags, e_swp, m_a1, m_a2,
 m_r1_op, m_r2_op, r_a1, r_a2, r_op, d_pass, d_pcincr, clk, rst);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] ex_a = pi_e_a, ex_b = pi_e_b; //operands  //input
\end_layout

\begin_layout Plain Layout

    wire [31:0] ex_st = reg_stout; //status register  //input
\end_layout

\begin_layout Plain Layout

    wire [7:0] ex_alu_op = pi_e_alu_op; // alu operation  //input
\end_layout

\begin_layout Plain Layout

    wire ex_is_cond = pi_e_is_cond; //is a conditional command signal  //input
\end_layout

\begin_layout Plain Layout

    wire [3:0] ex_cond = pi_e_cond; //cc  //input
\end_layout

\begin_layout Plain Layout

    wire [3:0] ex_write_flags = pi_e_write_flags; //write n/z/c/v  //input
\end_layout

\begin_layout Plain Layout

    wire ex_swp = pi_e_swp; //swap ops?  //input
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] ex_r1, ex_r2; //results, sync  //output
\end_layout

\begin_layout Plain Layout

    wire ex_n, ex_z, ex_c, ex_v; //flags, async  //output
\end_layout

\begin_layout Plain Layout

    wire ex_cc; //write flags, async  //output
\end_layout

\begin_layout Plain Layout

    wire ex_cres; //conditional results, sync  //output
\end_layout

\begin_layout Plain Layout

    execute ex0(ex_r1, ex_r2, ex_cres, ex_n, ex_z, ex_c, ex_v, ex_cc, ex_a,
 ex_b, ex_alu_op, ex_is_cond, ex_cond, ex_write_flags, ex_st, ex_swp, clk,
 rst);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire sr_n = ex_n, sr_z = ex_z, sr_c = ex_c, sr_v = ex_v; //input
\end_layout

\begin_layout Plain Layout

    wire sr_cc = ex_cc; //input
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] sr_st;  //output
\end_layout

\begin_layout Plain Layout

    assign reg_stin = sr_st;
\end_layout

\begin_layout Plain Layout

    wire sr_stwr; //output
\end_layout

\begin_layout Plain Layout

    assign reg_stwr = sr_stwr;
\end_layout

\begin_layout Plain Layout

    status_register_adaptor sr0(sr_st, sr_stwr, sr_n, sr_z, sr_c, sr_v,
 sr_cc);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] ex_m_a1, ex_m_a2; //(mem_op) //output
\end_layout

\begin_layout Plain Layout

    wire [3:0] ex_m_r1_op, ex_m_r2_op; //(mem_op) //output
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [4:0] ex_r_a1, ex_r_a2; //(reg_wb) //output
\end_layout

\begin_layout Plain Layout

    wire [3:0] ex_r_op; //(reg_wb) //output
\end_layout

\begin_layout Plain Layout

    execute_stage_passthrough exh0(ex_m_a1, ex_m_a2, ex_m_r1_op, ex_m_r2_op,
 ex_r_a1, ex_r_a2, ex_r_op, pi_m_a1, pi_m_a2, pi_m_r1_op, pi_m_r2_op, pi_r_a1,
 pi_r_a2, pi_r_op, clk, rst);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] mop_r1 = ex_r1, mop_r2 = ex_r2; //inputs  //input
\end_layout

\begin_layout Plain Layout

    wire [31:0] mop_a1 = ex_m_a1, mop_a2 = ex_m_a2; //memory addresses 
 //input
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [3:0] mop_r1_op = ex_m_r1_op, mop_r2_op = ex_m_r2_op; //operation
 codes  //input
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] mop_ram_r_line = ram_r_line, mop_sys_r_line = sys_r_line;
 // read lanes  //input
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire mop_proceed = ex_cres; //conditional code test result  //input
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] mop_m1, mop_m2; //outputs  //output
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] mop_ram_w_addr, mop_sys_w_addr; //write addresses  //output
\end_layout

\begin_layout Plain Layout

    assign ram_w_addr = mop_ram_w_addr, sys_w_addr = mop_sys_w_addr;
\end_layout

\begin_layout Plain Layout

    wire [31:0] mop_ram_r_addr, mop_sys_r_addr; //read addresses  //output
\end_layout

\begin_layout Plain Layout

    assign ram_r_addr = mop_ram_r_addr, sys_r_addr = mop_sys_r_addr;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] mop_ram_w_line, mop_sys_w_line; //write lanes  //output
\end_layout

\begin_layout Plain Layout

    assign ram_w_line = mop_ram_w_line, sys_w_line = mop_sys_w_line;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire mop_ram_w, mop_sys_w, mop_ram_r, mop_sys_r; //read/write signals
  //output
\end_layout

\begin_layout Plain Layout

    assign ram_write = mop_ram_w, sys_write = mop_sys_w, ram_read = mop_ram_r,
 sys_read = mop_sys_r;
\end_layout

\begin_layout Plain Layout

    memory_op mop0( mop_m1, mop_m2, mop_ram_w_addr, mop_ram_r_addr, mop_ram_w,
 mop_ram_r, mop_ram_w_line, mop_sys_w_addr, mop_sys_r_addr, mop_sys_w, mop_sys_r
, mop_sys_w_line, mop_r1, mop_r2, mop_a1, mop_a2, mop_r1_op, mop_r2_op,
 mop_ram_r_line, mop_sys_r_line, mop_proceed, clk, rst);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [4:0] mop_r_a1, mop_r_a2; //(reg_wb)  //output
\end_layout

\begin_layout Plain Layout

    wire [3:0] mop_r_op; //(reg_wb)  //output
\end_layout

\begin_layout Plain Layout

    wire mop_proceed2;  //output
\end_layout

\begin_layout Plain Layout

    memory_op_stage_passthrough moph0(mop_r_a1, mop_r_a2, mop_r_op, mop_proceed2
, ex_r_a1, ex_r_a2, ex_r_op, ex_cres, clk, rst);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] rwb_r1 = mop_m1, rwb_r2 = mop_m2;  //input
\end_layout

\begin_layout Plain Layout

    wire [4:0] rwb_a1 = mop_r_a1, rwb_a2 = mop_r_a2;  //input
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [3:0] rwb_op = mop_r_op;  //input
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire rwb_proceed = mop_proceed2;  //input
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] rwb_wr1, rwb_wr2;  //output
\end_layout

\begin_layout Plain Layout

    assign reg_c = rwb_wr1, reg_d = rwb_wr2;
\end_layout

\begin_layout Plain Layout

    wire [4:0] rwb_wa1, rwb_wa2;  //output
\end_layout

\begin_layout Plain Layout

    assign reg_a_c = rwb_wa1, reg_a_d = rwb_wa2;
\end_layout

\begin_layout Plain Layout

    wire [1:0] rwb_write;  //output
\end_layout

\begin_layout Plain Layout

    assign reg_write = rwb_write;
\end_layout

\begin_layout Plain Layout

    register_wb rwb0( rwb_write, rwb_wr1, rwb_wr2, rwb_wa1, rwb_wa2, rwb_r1,
 rwb_r2, rwb_a1, rwb_a2, rwb_op, rwb_proceed, clk, rst);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire ex_hazard;
\end_layout

\begin_layout Plain Layout

    wire reg_hazard;
\end_layout

\begin_layout Plain Layout

    wire mem_hazard;
\end_layout

\begin_layout Plain Layout

    reg_hazard_checker hz0(ex_hazard, mem_hazard, reg_hazard, ex_r_a1, ex_r_a2,
 ex_r_op, ex_cres, mop_r_a1, mop_r_a2, mop_r_op, mop_proceed2, rwb_wa1,
 rwb_wa2, rwb_write, r_r1_a, r_r2_a, r_read);
\end_layout

\begin_layout Plain Layout

`ifdef RWB_STAGE_HAZARD
\end_layout

\begin_layout Plain Layout

    assign d_hazard = ex_hazard || reg_hazard || mem_hazard;
\end_layout

\begin_layout Plain Layout

`else
\end_layout

\begin_layout Plain Layout

    assign d_hazard = ex_hazard || mem_hazard;
\end_layout

\begin_layout Plain Layout

`endif
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign lr = reg_lr;
\end_layout

\begin_layout Plain Layout

    assign pc = reg_pc;
\end_layout

\begin_layout Plain Layout

    assign st = reg_stout;
\end_layout

\begin_layout Plain Layout

    assign sp = reg_sp;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
test_processor_assembly.v
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Verilog,numbers=left,basicstyle={\scriptsize\rmfamily},breaklines=true,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

`timescale 1 ns / 100 ps
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

`define INTERFACE_STAGE_NO_DELAY
\end_layout

\begin_layout Plain Layout

`define RWB_STAGE_HAZARD
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

`include "test_pipeline_assembly.v"
\end_layout

\begin_layout Plain Layout

`include "test_periph_assembly.v"
\end_layout

\begin_layout Plain Layout

`include "ram.v"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// BEWARE:
\end_layout

\begin_layout Plain Layout

// general rule for continuous assignment statements
\end_layout

\begin_layout Plain Layout

// you can use continuous assignment in instantiation (e.g.
 wire a = b;) only if a - input and b - output
\end_layout

\begin_layout Plain Layout

// if we got reverse situation, we must provide good continuous assignment
 below ( assign b = a )
\end_layout

\begin_layout Plain Layout

// "continuous assignment is not bidirectional; it have dataflow directed
 from rvalue to lvalue"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module test_processor_assembly(lr, sp, st, pc, pins,  insn, clk, rst);
\end_layout

\begin_layout Plain Layout

    input [31:0] insn;
\end_layout

\begin_layout Plain Layout

    input clk, rst;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    output wire [31:0] lr, sp, st, pc; //special registers
\end_layout

\begin_layout Plain Layout

    inout [127:0] pins; //device pins
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] ram_w_addr, ram_r_addr; //input
\end_layout

\begin_layout Plain Layout

    wire [31:0] ram_w_line, ram_r_line; //input, output
\end_layout

\begin_layout Plain Layout

    wire ram_read, ram_write, ram_exception; //output
\end_layout

\begin_layout Plain Layout

    emb_ram ram0(ram_r_addr, ram_w_addr, ram_r_line, ram_w_line, ram_read,
 ram_write, ram_exception, clk);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] core_word = insn; //input
\end_layout

\begin_layout Plain Layout

    wire [31:0] core_ram_w_addr, core_ram_r_addr; //output
\end_layout

\begin_layout Plain Layout

    assign ram_w_addr = core_ram_w_addr, ram_r_addr = core_ram_r_addr;
\end_layout

\begin_layout Plain Layout

    wire [31:0] core_ram_w_line; //output
\end_layout

\begin_layout Plain Layout

    assign ram_w_line = core_ram_w_line;
\end_layout

\begin_layout Plain Layout

    wire [31:0] core_ram_r_line = ram_r_line; //input
\end_layout

\begin_layout Plain Layout

    wire core_ram_read, core_ram_write; //output
\end_layout

\begin_layout Plain Layout

    assign ram_read = core_ram_read, ram_write = core_ram_write;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] core_sys_w_addr, core_sys_r_addr; //output
\end_layout

\begin_layout Plain Layout

    wire [31:0] core_sys_w_line; //output
\end_layout

\begin_layout Plain Layout

    wire [31:0] core_sys_r_line; //input
\end_layout

\begin_layout Plain Layout

    wire core_sys_read, core_sys_write; //output
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [31:0] core_lr, core_sp, core_pc, core_st; //output
\end_layout

\begin_layout Plain Layout

    assign lr = core_lr, sp = core_sp, pc = core_pc, st = core_st;
\end_layout

\begin_layout Plain Layout

    test_pipeline_assembly core0(core_ram_w_addr, core_ram_r_addr, core_ram_w_li
ne, core_ram_read, core_ram_write, core_sys_w_addr, core_sys_r_addr, core_sys_w_
line, core_sys_read, core_sys_write, core_lr, core_sp, core_pc, core_st,
  core_word, core_ram_r_line, core_sys_r_line, clk, rst);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    test_periph_assembly periph0(pins, core_sys_w_addr, core_sys_r_addr,
 core_sys_w_line, core_sys_r_line, core_sys_write, core_sys_read, rst, clk);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
main.v
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Verilog,numbers=left,basicstyle={\scriptsize\rmfamily},breaklines=true,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

`timescale 1 ns / 100 ps
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

`include "test_processor_assembly.v"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module test_rom(word, addr);
\end_layout

\begin_layout Plain Layout

        input [31:0] addr;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        output wire [31:0] word;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        reg [31:0] insn;
\end_layout

\begin_layout Plain Layout

        assign word = insn;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        always @(addr) begin
\end_layout

\begin_layout Plain Layout

                #1;
\end_layout

\begin_layout Plain Layout

                case(addr)
\end_layout

\begin_layout Plain Layout

                        /*32'h0: begin //(mov)nop reg 29 to reg 30
\end_layout

\begin_layout Plain Layout

                            insn[31:25] <= 00; insn[24:21] <= 4'b1110; insn[20:1
6] <= 29; insn[15:11] <= 0; insn[10:6] <= 30; insn[5:1] <= 0; insn[0] <=
 0;
\end_layout

\begin_layout Plain Layout

                        end*/
\end_layout

\begin_layout Plain Layout

                        32'h0: begin //movs imm to reg 30 (sp)
\end_layout

\begin_layout Plain Layout

                            insn[31:25] <= 33; insn[24:21] <= 4'b1110; insn[20:1
1] <= 0; insn[10:6] <= 30; insn[5:1] <= 5'b10000; insn[0] <= 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h1: begin
\end_layout

\begin_layout Plain Layout

                            insn <= 32'h14888;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h3: begin //movs imm to reg 29 (lr)
\end_layout

\begin_layout Plain Layout

                            insn[31:25] <= 33; insn[24:21] <= 4'b1110; insn[20:1
1] <= 0; insn[10:6] <= 29; insn[5:1] <= 5'b10000; insn[0] <= 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h4: begin
\end_layout

\begin_layout Plain Layout

                            insn <= 32'h22888;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h5: begin //add 29 and 30 to 30
\end_layout

\begin_layout Plain Layout

                            insn[31:25] <= 14; insn[24:21] <= 4'b1110; insn[20:1
6] <= 29; insn[15:11] <= 30; insn[10:6] <= 30; insn[5:1] <= 5'b00000; insn[0]
 <= 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h6: begin //add imm1 and imm2 to 29
\end_layout

\begin_layout Plain Layout

                            insn[31:25] <= 14; insn[24:21] <= 4'b1110; insn[20:1
6] <= 0; insn[15:11] <= 0; insn[10:6] <= 29; insn[5:1] <= 5'b11000; insn[0]
 <= 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h7: begin
\end_layout

\begin_layout Plain Layout

                            insn <= 32'h35942;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h8: begin
\end_layout

\begin_layout Plain Layout

                            insn <= 32'hDEADBEAF;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h9: begin //mul 29 and 30 to 29 and 30
\end_layout

\begin_layout Plain Layout

                            insn[31:25] <= 18; insn[24:21] <= 4'b1110; insn[20:1
6] <= 29; insn[15:11] <= 30; insn[10:6] <= 29; insn[5:1] <= 30; insn[0]
 <= 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'hA: begin //xor 29 and 30 to 30
\end_layout

\begin_layout Plain Layout

                            insn[31:25] <= 6; insn[24:21] <= 4'b1110; insn[20:16
] <= 29; insn[15:11] <= 30; insn[10:6] <= 30; insn[5:1] <= 00; insn[0] <=
 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'hB: begin //csr 30 by imm to 29
\end_layout

\begin_layout Plain Layout

                            insn[31:25] <= 12; insn[24:21] <= 4'b1110; insn[20:1
6] <= 30; insn[15:11] <= 0; insn[10:6] <= 29; insn[5:1] <= 5'b01000; insn[0]
 <= 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'hC: begin
\end_layout

\begin_layout Plain Layout

                            insn <= 11;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'hD: begin //branch to imm
\end_layout

\begin_layout Plain Layout

                            insn[31:25] <= 25; insn[24:21] <= 4'b1110; insn[20:1
6] <= 0; insn[15:11] <= 0; insn[10:6] <= 0; insn[5:1] <= 5'b10000; insn[0]
 <= 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'hE: begin
\end_layout

\begin_layout Plain Layout

                            insn <= 32'h132;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h132: begin //out 29 to 30
\end_layout

\begin_layout Plain Layout

                            insn[31:25] <= 32; insn[24:21] <= 4'b1110; insn[20:1
6] <= 30; insn[15:11] <= 29; insn[10:6] <= 0; insn[5:1] <= 0; insn[0] <=
 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h133: begin //out 30 to 29
\end_layout

\begin_layout Plain Layout

                            insn[31:25] <= 32; insn[24:21] <= 4'b1110; insn[20:1
6] <= 29; insn[15:11] <= 30; insn[10:6] <= 0; insn[5:1] <= 0; insn[0] <=
 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h134: begin //brl to 30
\end_layout

\begin_layout Plain Layout

                            insn[31:25] <= 27; insn[24:21] <= 4'b1110; insn[20:1
6] <= 30; insn[15:11] <= 0; insn[10:6] <= 0; insn[5:1] <= 5'b00000; insn[0]
 <= 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h135: begin //str to imm from 30
\end_layout

\begin_layout Plain Layout

                            insn[31:25] <= 30; insn[24:21] <= 4'b1110; insn[20:1
6] <= 0; insn[15:11] <= 30; insn[10:6] <= 0; insn[5:1] <= 5'b10000; insn[0]
 <= 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h136: begin
\end_layout

\begin_layout Plain Layout

                            insn <= 16;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h137: begin //mov 29, 30 to 30, 29
\end_layout

\begin_layout Plain Layout

                            insn[31:25] <= 34; insn[24:21] <= 4'b1110; insn[20:1
6] <= 29; insn[15:11] <= 30; insn[10:6] <= 30; insn[5:1] <= 29; insn[0]
 <= 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h138: begin //out 30 to 29
\end_layout

\begin_layout Plain Layout

                            insn[31:25] <= 32; insn[24:21] <= 4'b1110; insn[20:1
6] <= 29; insn[15:11] <= 30; insn[10:6] <= 0; insn[5:1] <= 0; insn[0] <=
 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h139: begin //ldr from imm to 30
\end_layout

\begin_layout Plain Layout

                            insn[31:25] <= 29; insn[24:21] <= 4'b1110; insn[20:1
6] <= 0; insn[15:11] <= 0; insn[10:6] <= 30; insn[5:1] <= 5'b10000; insn[0]
 <= 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h13A: begin
\end_layout

\begin_layout Plain Layout

                            insn <= 16;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h13B:  begin //movs imm to r1
\end_layout

\begin_layout Plain Layout

                            insn[31:25] <= 33; insn[24:21] <= 4'b1110; insn[20:1
6] <= 0; insn[15:11] <= 0; insn[10:6] <= 1; insn[5:1] <= 5'b10000; insn[0]
 <= 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h13C: begin
\end_layout

\begin_layout Plain Layout

                            insn <= 32'hFFFFFFFF;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h13D: begin //out to imm from r1
\end_layout

\begin_layout Plain Layout

                            insn[31:25] <= 32; insn[24:21] <= 4'b1110; insn[20:1
6] <= 0; insn[15:11] <= 1; insn[10:6] <= 0; insn[5:1] <= 5'b10000; insn[0]
 <= 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h13E: begin
\end_layout

\begin_layout Plain Layout

                            insn <= 32'hD;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h13F: begin //out to imm from r1
\end_layout

\begin_layout Plain Layout

                            insn[31:25] <= 32; insn[24:21] <= 4'b1110; insn[20:1
6] <= 0; insn[15:11] <= 1; insn[10:6] <= 0; insn[5:1] <= 5'b10000; insn[0]
 <= 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h140: begin
\end_layout

\begin_layout Plain Layout

                            insn <= 32'hF;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h141: begin //out to imm from r1
\end_layout

\begin_layout Plain Layout

                            insn[31:25] <= 32; insn[24:21] <= 4'b1110; insn[20:1
6] <= 0; insn[15:11] <= 1; insn[10:6] <= 0; insn[5:1] <= 5'b10000; insn[0]
 <= 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h142: begin
\end_layout

\begin_layout Plain Layout

                            insn <= 32'h11;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h143: begin //out to imm from r1
\end_layout

\begin_layout Plain Layout

                            insn[31:25] <= 32; insn[24:21] <= 4'b1110; insn[20:1
6] <= 0; insn[15:11] <= 1; insn[10:6] <= 0; insn[5:1] <= 5'b10000; insn[0]
 <= 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h144: begin
\end_layout

\begin_layout Plain Layout

                            insn <= 32'hE;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h145: begin //in from imm to 30
\end_layout

\begin_layout Plain Layout

                            insn[31:25] <= 31; insn[24:21] <= 4'b1110; insn[20:1
6] <= 0; insn[15:11] <= 0; insn[10:6] <= 30; insn[5:1] <= 5'b10000; insn[0]
 <= 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h146: begin
\end_layout

\begin_layout Plain Layout

                            insn <= 32'hA;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h5E771E7D: begin //br_pos to 0
\end_layout

\begin_layout Plain Layout

                            insn[31:25] <= 25; insn[24:21] <= 4'b0101; insn[20:1
6] <= 0; insn[15:11] <= 0; insn[10:6] <= 0; insn[5:1] <= 5'b00000; insn[0]
 <= 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h5E771E7E: begin //ret_neg
\end_layout

\begin_layout Plain Layout

                            insn[31:25] <= 28; insn[24:21] <= 4'b0100; insn[20:1
6] <= 0; insn[15:11] <= 0; insn[10:6] <= 0; insn[5:1] <= 5'b00000; insn[0]
 <= 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        default: begin
\end_layout

\begin_layout Plain Layout

                            insn <= 32'b0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                endcase
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module fib32_rom(word, addr);
\end_layout

\begin_layout Plain Layout

        input [31:0] addr;
\end_layout

\begin_layout Plain Layout

        output reg [31:0] word;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        always @* begin
\end_layout

\begin_layout Plain Layout

                #1;
\end_layout

\begin_layout Plain Layout

                case(addr)
\end_layout

\begin_layout Plain Layout

                        32'h0: begin //movs 0x00 -> r0
\end_layout

\begin_layout Plain Layout

                                word[31:25] = 33; word[24:21] = 4'b1110;
 word[20:16] = 0; word[15:11] = 0; word[10:6] = 0; word[5:1] = 5'b10000;
 word[0] = 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h1: begin
\end_layout

\begin_layout Plain Layout

                                word = 32'h0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h2: begin //movs 0xFFFFFFFF -> r1
\end_layout

\begin_layout Plain Layout

                                word[31:25] = 33; word[24:21] = 4'b1110;
 word[20:16] = 0; word[15:11] = 0; word[10:6] = 1; word[5:1] = 5'b10000;
 word[0] = 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h3: begin
\end_layout

\begin_layout Plain Layout

                                word = 32'hFFFFFFFF;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h4: begin //movs r0 -> r2
\end_layout

\begin_layout Plain Layout

                                word[31:25] = 33; word[24:21] = 4'b1110;
 word[20:16] = 0; word[15:11] = 0; word[10:6] = 2; word[5:1] = 5'b00000;
 word[0] = 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h5: begin //movs 0x01 -> r3
\end_layout

\begin_layout Plain Layout

                                word[31:25] = 33; word[24:21] = 4'b1110;
 word[20:16] = 0; word[15:11] = 0; word[10:6] = 3; word[5:1] = 5'b10000;
 word[0] = 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h6: begin
\end_layout

\begin_layout Plain Layout

                                word = 32'h1;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h7: begin //movs 0x0C -> r5
\end_layout

\begin_layout Plain Layout

                                word[31:25] = 33; word[24:21] = 4'b1110;
 word[20:16] = 0; word[15:11] = 0; word[10:6] = 5; word[5:1] = 5'b10000;
 word[0] = 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h8: begin
\end_layout

\begin_layout Plain Layout

                                word = 32'hC;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h9: begin //movs 0x100 -> r6
\end_layout

\begin_layout Plain Layout

                                word[31:25] = 33; word[24:21] = 4'b1110;
 word[20:16] = 0; word[15:11] = 0; word[10:6] = 6; word[5:1] = 5'b10000;
 word[0] = 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'hA: begin
\end_layout

\begin_layout Plain Layout

                                word = 32'h100;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'hB: begin //movs -0x03 -> r7
\end_layout

\begin_layout Plain Layout

                                word[31:25] = 33; word[24:21] = 4'b1110;
 word[20:16] = 0; word[15:11] = 0; word[10:6] = 7; word[5:1] = 5'b10000;
 word[0] = 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'hC: begin
\end_layout

\begin_layout Plain Layout

                                word = 32'hFFFFFFFD;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'hD: begin //out r1 -> 0x0D
\end_layout

\begin_layout Plain Layout

                                word[31:25] = 32; word[24:21] = 4'b1110;
 word[20:16] = 0; word[15:11] = 1; word[10:6] = 0; word[5:1] = 5'b10000;
 word[0] = 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'hE: begin
\end_layout

\begin_layout Plain Layout

                                word = 32'hD;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'hF: begin //out r3 -> [r5]
\end_layout

\begin_layout Plain Layout

                                word[31:25] = 32; word[24:21] = 4'b1110;
 word[20:16] = 5; word[15:11] = 3; word[10:6] = 0; word[5:1] = 5'b00000;
 word[0] = 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h10: begin //brl [r6]
\end_layout

\begin_layout Plain Layout

                                word[31:25] = 27; word[24:21] = 4'b1110;
 word[20:16] = 6; word[15:11] = 0; word[10:6] = 0; word[5:1] = 5'b00000;
 word[0] = 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h11: begin //out_lo r4 -> [r5]
\end_layout

\begin_layout Plain Layout

                                word[31:25] = 32; word[24:21] = 4'b0011;
 word[20:16] = 5; word[15:11] = 4; word[10:6] = 0; word[5:1] = 5'b00000;
 word[0] = 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h12: begin //rbr_lo pc+r7
\end_layout

\begin_layout Plain Layout

                                word[31:25] = 26; word[24:21] = 4'b0011;
 word[20:16] = 7; word[15:11] = 0; word[10:6] = 0; word[5:1] = 5'b00000;
 word[0] = 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h13: begin //br r0
\end_layout

\begin_layout Plain Layout

                                word[31:25] = 25; word[24:21] = 4'b1110;
 word[20:16] = 0; word[15:11] = 0; word[10:6] = 0; word[5:1] = 5'b00000;
 word[0] = 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        //fib()
\end_layout

\begin_layout Plain Layout

                        32'h100: begin //add r2, r3 -> r4
\end_layout

\begin_layout Plain Layout

                                word[31:25] = 14; word[24:21] = 4'b1110;
 word[20:16] = 2; word[15:11] = 3; word[10:6] = 4; word[5:1] = 5'b00000;
 word[0] = 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h101: begin //mov r3,r4 -> r2, r3
\end_layout

\begin_layout Plain Layout

                                word[31:25] = 34; word[24:21] = 4'b1110;
 word[20:16] = 3; word[15:11] = 4; word[10:6] = 2; word[5:1] = 3; word[0]
 = 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        32'h102: begin //ret
\end_layout

\begin_layout Plain Layout

                                word[31:25] = 28; word[24:21] = 4'b1110;
 word[20:16] = 0; word[15:11] = 0; word[10:6] = 0; word[5:1] = 5'b00000;
 word[0] = 0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                        default: begin //nop
\end_layout

\begin_layout Plain Layout

                                word = 32'h0;
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                endcase
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//assembly test
\end_layout

\begin_layout Plain Layout

module main();
\end_layout

\begin_layout Plain Layout

    wire [31:0] insn;
\end_layout

\begin_layout Plain Layout

    wire [31:0] lr, sp, st, pc;
\end_layout

\begin_layout Plain Layout

    wire [31:0] pins0, pins1, pins2, pins3;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    reg clk;
\end_layout

\begin_layout Plain Layout

    reg rst;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    test_processor_assembly proc0(lr, sp, st, pc, {pins3, pins2, pins1,
 pins0}, insn, clk, rst);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    fib32_rom rom0(insn, pc);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    assign pins0[15:0] = 16'h1488;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    initial begin
\end_layout

\begin_layout Plain Layout

        //insn = 32'b0; //nop
\end_layout

\begin_layout Plain Layout

        clk = 0;
\end_layout

\begin_layout Plain Layout

        rst = 0;
\end_layout

\begin_layout Plain Layout

        $dumpfile("dump.fst");
\end_layout

\begin_layout Plain Layout

        $dumpvars(0);
\end_layout

\begin_layout Plain Layout

        $dumpon;
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

    always begin
\end_layout

\begin_layout Plain Layout

        integer i;
\end_layout

\begin_layout Plain Layout

        //reset
\end_layout

\begin_layout Plain Layout

        rst = 0;
\end_layout

\begin_layout Plain Layout

        #20;
\end_layout

\begin_layout Plain Layout

        rst = 1;
\end_layout

\begin_layout Plain Layout

        #20;
\end_layout

\begin_layout Plain Layout

        rst = 0;
\end_layout

\begin_layout Plain Layout

        #20;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        //clock 128 times
\end_layout

\begin_layout Plain Layout

        for(i =0; i < 1024+128; i++) begin
\end_layout

\begin_layout Plain Layout

            #20;
\end_layout

\begin_layout Plain Layout

            clk = 1;
\end_layout

\begin_layout Plain Layout

            #20;
\end_layout

\begin_layout Plain Layout

            clk = 0;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        //finish
\end_layout

\begin_layout Plain Layout

        $dumpflush;
\end_layout

\begin_layout Plain Layout

        $finish;
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//shifter test
\end_layout

\begin_layout Plain Layout

function [31:0] rotr;
\end_layout

\begin_layout Plain Layout

    input[31:0] a;
\end_layout

\begin_layout Plain Layout

    input[4:0] b;
\end_layout

\begin_layout Plain Layout

    rotr = ( a >> b) | (a << ((-b) & 31));
\end_layout

\begin_layout Plain Layout

endfunction
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

function [31:0] rotl;
\end_layout

\begin_layout Plain Layout

    input[31:0] a;
\end_layout

\begin_layout Plain Layout

    input[4:0] b;
\end_layout

\begin_layout Plain Layout

    rotl = ( a << b) | (a >> ((-b) & 31));
\end_layout

\begin_layout Plain Layout

endfunction
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

function [31:0] sal;
\end_layout

\begin_layout Plain Layout

    input[31:0] a;
\end_layout

\begin_layout Plain Layout

    input[4:0] b;
\end_layout

\begin_layout Plain Layout

    sal[30:0] = (a[30:0] << b);
\end_layout

\begin_layout Plain Layout

    sal[31] = a[31];
\end_layout

\begin_layout Plain Layout

endfunction
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

function [31:0] sar;
\end_layout

\begin_layout Plain Layout

    input[31:0] a;
\end_layout

\begin_layout Plain Layout

    input[4:0] b;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    integer x;
\end_layout

\begin_layout Plain Layout

    x = a;
\end_layout

\begin_layout Plain Layout

    //if(a[31]) x = -x;
\end_layout

\begin_layout Plain Layout

    sar = x >>> b;
\end_layout

\begin_layout Plain Layout

endfunction
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
MultiplierGenerator
\end_layout

\begin_layout Subsubsection
Gate.hpp
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},numbers=left,basicstyle={\scriptsize\rmfamily},breaklines=true,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

#ifndef GATE_HPP_INCLUDED
\end_layout

\begin_layout Plain Layout

#define GATE_HPP_INCLUDED
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#include <string>
\end_layout

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

#include <atomic>
\end_layout

\begin_layout Plain Layout

#include <vector>
\end_layout

\begin_layout Plain Layout

#include <cmath>
\end_layout

\begin_layout Plain Layout

#include <stdexcept>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Gate{
\end_layout

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

    virtual void genWire(std::ostream& out) = 0;
\end_layout

\begin_layout Plain Layout

    virtual void genInst(std::ostream& out) = 0;
\end_layout

\begin_layout Plain Layout

    virtual string name() = 0;
\end_layout

\begin_layout Plain Layout

    virtual unsigned int count() = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    virtual ~Gate() {};
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class InputGate: public Gate{
\end_layout

\begin_layout Plain Layout

    string vnm;
\end_layout

\begin_layout Plain Layout

    unsigned int vref;
\end_layout

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

    InputGate(): vnm(), vref(0) {};
\end_layout

\begin_layout Plain Layout

    InputGate(std::string vname, unsigned int vnumber): vnm(vname), vref(vnumber
) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    void genWire(std::ostream& out) override{
\end_layout

\begin_layout Plain Layout

        return;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    void genInst(std::ostream& out) override{
\end_layout

\begin_layout Plain Layout

        return;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    string name() override{
\end_layout

\begin_layout Plain Layout

        return (vnm + "[" + to_string(vref)+"]");
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    unsigned int count() override{ return 0;}
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class OutputGate: public Gate{
\end_layout

\begin_layout Plain Layout

    string vnm;
\end_layout

\begin_layout Plain Layout

    unsigned int vref;
\end_layout

\begin_layout Plain Layout

    Gate* in;
\end_layout

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

    OutputGate(): vnm(), vref(0), in(nullptr) {};
\end_layout

\begin_layout Plain Layout

    OutputGate(std::string vname, unsigned int vnumber, Gate* in1): vnm(vname),
 vref(vnumber), in(in1) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    void genWire(std::ostream& out) override{
\end_layout

\begin_layout Plain Layout

        out << "
\backslash
tassign " << vnm << "[" << vref << "]" << " = " << in->name() << ";
\backslash
n";
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    void genInst(std::ostream& out) override{
\end_layout

\begin_layout Plain Layout

        return;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    string name() override{
\end_layout

\begin_layout Plain Layout

        return (vnm + "[" + to_string(vref)+"]");
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    unsigned int count() override{ return 0;}
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class ANDGate: public Gate{
\end_layout

\begin_layout Plain Layout

    unsigned int nref;
\end_layout

\begin_layout Plain Layout

    Gate *in1, *in2;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    static atomic_uint cnt;
\end_layout

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

    ANDGate(): nref(cnt++), in1(nullptr), in2(nullptr) {};
\end_layout

\begin_layout Plain Layout

    ANDGate(Gate* in1, Gate* in2): nref(cnt++), in1(in1), in2(in2) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    void genWire(std::ostream& out) override{
\end_layout

\begin_layout Plain Layout

        out << "
\backslash
twire wand_" << nref << ";
\backslash
n";
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    void genInst(std::ostream& out) override{
\end_layout

\begin_layout Plain Layout

        out << "
\backslash
tand #1 and_" << nref << "( wand_" << nref <<", " << in1->name() << ", "
 << in2->name() << ");
\backslash
n";
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    string name() override{
\end_layout

\begin_layout Plain Layout

        return ("wand_" + to_string(nref));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    unsigned int count() override{ return 1;}
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class FAProvider: public Gate{
\end_layout

\begin_layout Plain Layout

    unsigned int nref;
\end_layout

\begin_layout Plain Layout

    Gate *in1, *in2, *in3;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    static atomic_uint cnt;
\end_layout

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

    FAProvider(): nref(cnt++), in1(nullptr), in2(nullptr), in3(nullptr)
 {};
\end_layout

\begin_layout Plain Layout

    FAProvider(Gate* a, Gate* b, Gate* _cin): nref(cnt++), in1(a), in2(b),
 in3(_cin) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    void genWire(std::ostream& out) override{
\end_layout

\begin_layout Plain Layout

        out << "
\backslash
twire wfa_s_" << nref << ", wfa_cout_" << nref << ";
\backslash
n";
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    void genInst(std::ostream& out) override{
\end_layout

\begin_layout Plain Layout

        out << "
\backslash
tfa fa_" << nref << "( " << in1->name() << ", " << in2->name() << ", " <<
 in3->name() << ", wfa_s_" << nref << ", wfa_cout_" << nref << ");
\backslash
n";
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    string name() override{
\end_layout

\begin_layout Plain Layout

        ///It is only provider, not node
\end_layout

\begin_layout Plain Layout

        return string();
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    unsigned int count() override{ return 5;}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    unsigned int getRef(){ return nref; }
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class FANode_S: public Gate{
\end_layout

\begin_layout Plain Layout

    FAProvider* p;
\end_layout

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

    FANode_S(): p(nullptr) {};
\end_layout

\begin_layout Plain Layout

    FANode_S(FAProvider* prov): p(prov) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    void genWire(std::ostream& out) override{
\end_layout

\begin_layout Plain Layout

        ///It's only node, not provider
\end_layout

\begin_layout Plain Layout

        return;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    void genInst(std::ostream& out) override{
\end_layout

\begin_layout Plain Layout

        ///It's only node, not provider
\end_layout

\begin_layout Plain Layout

        return;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    string name() override{
\end_layout

\begin_layout Plain Layout

        return ("wfa_s_" + to_string(p->getRef()));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    unsigned int count() override{ return 0;}
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class FANode_Cout: public Gate{
\end_layout

\begin_layout Plain Layout

    FAProvider* p;
\end_layout

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

    FANode_Cout(): p(nullptr) {};
\end_layout

\begin_layout Plain Layout

    FANode_Cout(FAProvider* prov): p(prov) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    void genWire(std::ostream& out) override{
\end_layout

\begin_layout Plain Layout

        ///It's only node, not provider
\end_layout

\begin_layout Plain Layout

        return;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    void genInst(std::ostream& out) override{
\end_layout

\begin_layout Plain Layout

        ///It's only node, not provider
\end_layout

\begin_layout Plain Layout

        return;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    string name() override{
\end_layout

\begin_layout Plain Layout

        return ("wfa_cout_" + to_string(p->getRef()));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    unsigned int count() override{ return 0;}
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class HAProvider: public Gate{
\end_layout

\begin_layout Plain Layout

    unsigned int nref;
\end_layout

\begin_layout Plain Layout

    Gate *in1, *in2;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    static atomic_uint cnt;
\end_layout

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

    HAProvider(): nref(cnt++), in1(nullptr), in2(nullptr) {};
\end_layout

\begin_layout Plain Layout

    HAProvider(Gate* a, Gate* b): nref(cnt++), in1(a), in2(b) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    void genWire(std::ostream& out) override{
\end_layout

\begin_layout Plain Layout

        out << "
\backslash
twire wha_s_" << nref << ", wha_c_" << nref << ";
\backslash
n";
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    void genInst(std::ostream& out) override{
\end_layout

\begin_layout Plain Layout

        out << "
\backslash
tha ha_" << nref << "( " << in1->name() << ", " << in2->name() << ", wha_s_"
 << nref << ", wha_c_" << nref << ");
\backslash
n";
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    string name() override{
\end_layout

\begin_layout Plain Layout

        ///It is only provider, not node
\end_layout

\begin_layout Plain Layout

        return string();
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    unsigned int count() override{ return 2;}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    unsigned int getRef(){ return nref; }
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class HANode_S: public Gate{
\end_layout

\begin_layout Plain Layout

    HAProvider* p;
\end_layout

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

    HANode_S(): p(nullptr) {};
\end_layout

\begin_layout Plain Layout

    HANode_S(HAProvider* prov): p(prov) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    void genWire(std::ostream& out) override{
\end_layout

\begin_layout Plain Layout

        ///It's only node, not provider
\end_layout

\begin_layout Plain Layout

        return;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    void genInst(std::ostream& out) override{
\end_layout

\begin_layout Plain Layout

        ///It's only node, not provider
\end_layout

\begin_layout Plain Layout

        return;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    string name() override{
\end_layout

\begin_layout Plain Layout

        return ("wha_s_" + to_string(p->getRef()));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    unsigned int count() override{ return 0;}
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class HANode_C: public Gate{
\end_layout

\begin_layout Plain Layout

    HAProvider* p;
\end_layout

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

    HANode_C(): p(nullptr) {};
\end_layout

\begin_layout Plain Layout

    HANode_C(HAProvider* prov): p(prov) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    void genWire(std::ostream& out) override{
\end_layout

\begin_layout Plain Layout

        ///It's only node, not provider
\end_layout

\begin_layout Plain Layout

        return;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    void genInst(std::ostream& out) override{
\end_layout

\begin_layout Plain Layout

        ///It's only node, not provider
\end_layout

\begin_layout Plain Layout

        return;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    string name() override{
\end_layout

\begin_layout Plain Layout

        return ("wha_c_" + to_string(p->getRef()));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    unsigned int count() override{ return 0;}
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

atomic_uint ANDGate::cnt;
\end_layout

\begin_layout Plain Layout

atomic_uint HAProvider::cnt;
\end_layout

\begin_layout Plain Layout

atomic_uint FAProvider::cnt;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void gen_mult(std::ostream& out, unsigned int opsz){
\end_layout

\begin_layout Plain Layout

    vector<unsigned int> gen_seq;
\end_layout

\begin_layout Plain Layout

    gen_seq.push_back(2);
\end_layout

\begin_layout Plain Layout

    while(gen_seq.back() < opsz){
\end_layout

\begin_layout Plain Layout

        unsigned int cur_seq = gen_seq.back();
\end_layout

\begin_layout Plain Layout

        gen_seq.push_back( (unsigned int)(floor(3.0*cur_seq/2.0)) );
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    gen_seq.pop_back();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    vector<Gate*>* wg = new vector<Gate*> [2*opsz];
\end_layout

\begin_layout Plain Layout

    vector<Gate*> ins1;
\end_layout

\begin_layout Plain Layout

    vector<Gate*> ins2;
\end_layout

\begin_layout Plain Layout

    vector<Gate*> used;
\end_layout

\begin_layout Plain Layout

    vector<Gate*> outs;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for(unsigned int i = 0; i < opsz; i++){
\end_layout

\begin_layout Plain Layout

        ins1.push_back(new InputGate("a", i));
\end_layout

\begin_layout Plain Layout

        ins2.push_back(new InputGate("b", i));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    cout << "Input generation
\backslash
n";
\end_layout

\begin_layout Plain Layout

    for(unsigned int i = 0; i < opsz; i++){
\end_layout

\begin_layout Plain Layout

        for(unsigned int j = 0; j < opsz; j++){
\end_layout

\begin_layout Plain Layout

            wg[i+j].push_back(new ANDGate(ins1[i], ins2[j]));
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    for(unsigned int i = 0; i < 2*opsz - 1; i++) cout << " Weight " << i
 << ", length " << wg[i].size() << "
\backslash
n";
\end_layout

\begin_layout Plain Layout

    cout << "
\backslash
n
\backslash
n";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    unsigned int i = 1;
\end_layout

\begin_layout Plain Layout

    while(gen_seq.size() > 0){ ///Reduce vectors towards ready-to-use entities
 (auto generate last adders layer)
\end_layout

\begin_layout Plain Layout

        unsigned int cur = gen_seq.back();
\end_layout

\begin_layout Plain Layout

        gen_seq.pop_back();
\end_layout

\begin_layout Plain Layout

        cout << "
\backslash
nLayer " << i << ", target " << cur << "
\backslash
n";
\end_layout

\begin_layout Plain Layout

        i++;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        for(unsigned int w = 0; w < 2*opsz - 1; w++){
\end_layout

\begin_layout Plain Layout

            cout << " Weight " << w << ", length " << wg[w].size() << "
\backslash
n";
\end_layout

\begin_layout Plain Layout

            if(wg[w].size() > cur){
\end_layout

\begin_layout Plain Layout

                vector<Gate*>& gs = wg[w];
\end_layout

\begin_layout Plain Layout

                vector<Gate*>& ngs = wg[w+1];
\end_layout

\begin_layout Plain Layout

                unsigned int s = gs.size();
\end_layout

\begin_layout Plain Layout

                while(s > cur){
\end_layout

\begin_layout Plain Layout

                    if((s - cur) >= 2){ ///Insert Full Adder
\end_layout

\begin_layout Plain Layout

                        Gate* a = gs[0];
\end_layout

\begin_layout Plain Layout

                        Gate* b = gs[1];
\end_layout

\begin_layout Plain Layout

                        Gate* _cin = gs[2];
\end_layout

\begin_layout Plain Layout

                        gs.erase(gs.begin(), gs.begin()+3);
\end_layout

\begin_layout Plain Layout

                        FAProvider* fa = new FAProvider(a, b, _cin);
\end_layout

\begin_layout Plain Layout

                        gs.push_back(new FANode_S(fa));
\end_layout

\begin_layout Plain Layout

                        ngs.push_back(new FANode_Cout(fa));
\end_layout

\begin_layout Plain Layout

                        used.push_back(a), used.push_back(b), used.push_back(_cin),
 used.push_back(fa);
\end_layout

\begin_layout Plain Layout

                        s -= 2;
\end_layout

\begin_layout Plain Layout

                        cout << "  Inserted Full Adder, now " << s << "
\backslash
n";
\end_layout

\begin_layout Plain Layout

                    }
\end_layout

\begin_layout Plain Layout

                    else if((s - cur) == 1){ ///Insert Half Adder
\end_layout

\begin_layout Plain Layout

                        Gate* a = gs[0];
\end_layout

\begin_layout Plain Layout

                        Gate* b = gs[1];
\end_layout

\begin_layout Plain Layout

                        gs.erase(gs.begin(), gs.begin()+2);
\end_layout

\begin_layout Plain Layout

                        HAProvider* ha = new HAProvider(a, b);
\end_layout

\begin_layout Plain Layout

                        gs.push_back(new HANode_S(ha));
\end_layout

\begin_layout Plain Layout

                        ngs.push_back(new HANode_C(ha));
\end_layout

\begin_layout Plain Layout

                        used.push_back(a), used.push_back(b), used.push_back(ha);
\end_layout

\begin_layout Plain Layout

                        s -= 1;
\end_layout

\begin_layout Plain Layout

                        cout << "  Inserted Half Adder, now " << s << "
\backslash
n";
\end_layout

\begin_layout Plain Layout

                    }
\end_layout

\begin_layout Plain Layout

                    else if((s - cur) == 0){ ///Connect to next layer
\end_layout

\begin_layout Plain Layout

                        s -= 0;
\end_layout

\begin_layout Plain Layout

                        cout << "  Passed to next layer, now" << s << "
\backslash
n";
\end_layout

\begin_layout Plain Layout

                    }
\end_layout

\begin_layout Plain Layout

                    else throw runtime_error("Bad condition in place #1");
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    cout << "
\backslash
n
\backslash
n";
\end_layout

\begin_layout Plain Layout

    ///Check if we're have good vectors
\end_layout

\begin_layout Plain Layout

    if(wg[0].size() != 1) throw runtime_error("First vector have " + to_string(wg
[0].size()) + " entities in it instead of 1");
\end_layout

\begin_layout Plain Layout

    for(unsigned int i = 1; i < 2*opsz - 1; i++)
\end_layout

\begin_layout Plain Layout

        if(wg[i].size() != 2) throw runtime_error("Vector " + to_string(i)
 + " have size " + to_string(wg[i].size()) + " instead of 2 after reduction");
\end_layout

\begin_layout Plain Layout

    if(wg[2*opsz - 1].size() != 0) throw runtime_error("Last (fill) vector
 have " + to_string(wg[2*opsz].size()) + " entities in it instead of 0");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    ///Add last two layers
\end_layout

\begin_layout Plain Layout

    cout << "Outputs layer, target 1" << endl;
\end_layout

\begin_layout Plain Layout

    for(unsigned int w = 0; w < 2*opsz; w++){
\end_layout

\begin_layout Plain Layout

        vector<Gate*>& gs = wg[w];
\end_layout

\begin_layout Plain Layout

        vector<Gate*>& ngs = wg[w+1];
\end_layout

\begin_layout Plain Layout

        unsigned int s = gs.size();
\end_layout

\begin_layout Plain Layout

        cout << " Weight " << w << ", length " << s << endl;
\end_layout

\begin_layout Plain Layout

        if(s == 2){
\end_layout

\begin_layout Plain Layout

            Gate* a = gs[0];
\end_layout

\begin_layout Plain Layout

            Gate* b = gs[1];
\end_layout

\begin_layout Plain Layout

            gs.erase(gs.begin(), gs.begin()+2);
\end_layout

\begin_layout Plain Layout

            HAProvider* ha = new HAProvider(a, b);
\end_layout

\begin_layout Plain Layout

            gs.push_back(new HANode_S(ha));
\end_layout

\begin_layout Plain Layout

            ngs.push_back(new HANode_C(ha));
\end_layout

\begin_layout Plain Layout

            used.push_back(a), used.push_back(b), used.push_back(ha);
\end_layout

\begin_layout Plain Layout

            s -= 1;
\end_layout

\begin_layout Plain Layout

            cout << "  Inserted Half Adder, now " << s << endl;
\end_layout

\begin_layout Plain Layout

        } else if( s == 3){
\end_layout

\begin_layout Plain Layout

            Gate* a = gs[0];
\end_layout

\begin_layout Plain Layout

            Gate* b = gs[1];
\end_layout

\begin_layout Plain Layout

            Gate* _cin = gs[2];
\end_layout

\begin_layout Plain Layout

            gs.erase(gs.begin(), gs.begin()+3);
\end_layout

\begin_layout Plain Layout

            FAProvider* fa = new FAProvider(a, b, _cin);
\end_layout

\begin_layout Plain Layout

            gs.push_back(new FANode_S(fa));
\end_layout

\begin_layout Plain Layout

            ngs.push_back(new FANode_Cout(fa));
\end_layout

\begin_layout Plain Layout

            used.push_back(a), used.push_back(b), used.push_back(_cin), used.push_ba
ck(fa);
\end_layout

\begin_layout Plain Layout

            s -= 2;
\end_layout

\begin_layout Plain Layout

            cout << "  Inserted Full Adder, now " << s << endl;
\end_layout

\begin_layout Plain Layout

        } else if (s == 1){
\end_layout

\begin_layout Plain Layout

            cout << "  Passed to the outputs layer" << endl;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    cout << "
\backslash
n
\backslash
n";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    ///Generate outputs
\end_layout

\begin_layout Plain Layout

    for(unsigned int i = 0; i < 2*opsz; i++){
\end_layout

\begin_layout Plain Layout

        Gate* ow = wg[i][0];
\end_layout

\begin_layout Plain Layout

        wg[i].clear();
\end_layout

\begin_layout Plain Layout

        outs.push_back(new OutputGate("m", i, ow));
\end_layout

\begin_layout Plain Layout

        used.push_back(ow);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    unsigned long int gates_number = 0;
\end_layout

\begin_layout Plain Layout

    for(Gate* i: used) gates_number += i->count();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    cout << "Approx.
 gates count: " << gates_number << "
\backslash
n" << endl;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    ///Generate rtl representation
\end_layout

\begin_layout Plain Layout

    for(Gate* i: used) i->genWire(out);
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
n";
\end_layout

\begin_layout Plain Layout

    for(Gate* i: used) i->genInst(out);
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
n";
\end_layout

\begin_layout Plain Layout

    for(Gate* i: outs) i->genWire(out);
\end_layout

\begin_layout Plain Layout

    for(Gate* i: outs) i->genInst(out);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    ///Cleanup
\end_layout

\begin_layout Plain Layout

    delete [] wg;
\end_layout

\begin_layout Plain Layout

    for(Gate* i: ins1) delete i;
\end_layout

\begin_layout Plain Layout

    for(Gate* i: ins2) delete i;
\end_layout

\begin_layout Plain Layout

    for(Gate* i: used) delete i;
\end_layout

\begin_layout Plain Layout

    for(Gate* i: outs) delete i;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void gen_incls(std::ostream& out){
\end_layout

\begin_layout Plain Layout

    ///generate full adder
\end_layout

\begin_layout Plain Layout

    out << "module fa(a,b,cin, s, cout);
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
tinput a;
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
tinput b;
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
tinput cin;
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
toutput s;
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
toutput cout;
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
twire w1, w2, w3;
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
txor #1 x1(w1, a, b);
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
txor #1 x2(s, w1, cin);
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
tand #1 a1(w2, a, b);
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
tand #1 a2(w3, w1, cin);
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
tor #1 o1(cout, w2, w3);
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "endmodule
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
n";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    ///generate half adder
\end_layout

\begin_layout Plain Layout

    out << "module ha(a,b,s,c);
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
tinput a;
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
tinput b;
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
toutput s;
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
toutput c;
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
txor #1 x(s, a, b);
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
tand #1 an(c, a, b);
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "endmodule
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
n";
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void gen_module_decl(std::ostream& out, unsigned int opsz){
\end_layout

\begin_layout Plain Layout

    out << "module mult_" << opsz << "(a, b, m);
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
tinput [" << (opsz-1) << ":0] a;
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
tinput [" << (opsz-1) << ":0] b;
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
toutput [" << (2*opsz-1) << ":0] m;
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
n
\backslash
n";
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void gen_module_end(std::ostream& out){
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "endmodule
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
n";
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void gen_header(std::ostream& out, unsigned int opsz){
\end_layout

\begin_layout Plain Layout

    out << "// This file is generated with MultiplierGenerator from CPU32
 project.
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "// (c) DeD MorozZz
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "// This is " << opsz << "x" << opsz << " bits parallel multiplier,
 Dadda tree design.
\backslash
n";
\end_layout

\begin_layout Plain Layout

    out << "
\backslash
n";
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#endif // GATE_HPP_INCLUDED
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Main.cpp
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},numbers=left,basicstyle={\scriptsize\rmfamily},breaklines=true,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

#include <fstream>
\end_layout

\begin_layout Plain Layout

#include <string>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#include "Gate.hpp"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(int argc, char** argv){
\end_layout

\begin_layout Plain Layout

    if(argc != 3){
\end_layout

\begin_layout Plain Layout

        cout << "Dadda Tree Multiplier Verilog representation generator.
\backslash
n
\backslash
tUsage:
\backslash
n
\backslash
t" << argv[0] << " <opsz> <outfile>" << endl;
\end_layout

\begin_layout Plain Layout

        return 0;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    ofstream out(argv[2]);
\end_layout

\begin_layout Plain Layout

    if(!out.is_open()){
\end_layout

\begin_layout Plain Layout

        cout << "Can't open outfile" << endl;
\end_layout

\begin_layout Plain Layout

        return -1;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    unsigned int opsz = atoi(argv[1]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    gen_header(out, opsz);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    gen_incls(out);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    gen_module_decl(out, opsz);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    gen_mult(out, opsz);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    gen_module_end(out);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    out.close();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
testcase.v
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Verilog,numbers=left,basicstyle={\scriptsize\rmfamily},breaklines=true,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

`timescale 1 ns / 10 ps
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

`include "test.v"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module main();
\end_layout

\begin_layout Plain Layout

    parameter s = 32;
\end_layout

\begin_layout Plain Layout

    parameter mx = 1 << s;
\end_layout

\begin_layout Plain Layout

    parameter dl = 64;
\end_layout

\begin_layout Plain Layout

    reg [s-1:0] a;
\end_layout

\begin_layout Plain Layout

    reg [s-1:0] b;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    wire [2*s-1:0] m;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    reg [s:0] i;
\end_layout

\begin_layout Plain Layout

    reg [s:0] j;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    mult_8 mult(a, b, m);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    initial begin
\end_layout

\begin_layout Plain Layout

        a = 0;
\end_layout

\begin_layout Plain Layout

        b = 0;
\end_layout

\begin_layout Plain Layout

        $dumpfile("dump.fst");
\end_layout

\begin_layout Plain Layout

        $dumpvars(0);
\end_layout

\begin_layout Plain Layout

        $dumpon;
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    always begin
\end_layout

\begin_layout Plain Layout

        for(i = 0; i < mx; i++ ) begin
\end_layout

\begin_layout Plain Layout

            for(j = 0; j < mx; j++) begin
\end_layout

\begin_layout Plain Layout

                a = i[s-1:0];
\end_layout

\begin_layout Plain Layout

                b = j[s-1:0];
\end_layout

\begin_layout Plain Layout

                #dl;
\end_layout

\begin_layout Plain Layout

                if(m != a*b) $display("Multiply error: %x*%x =? %x", a,
 b, m);
\end_layout

\begin_layout Plain Layout

            end
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

        a = 0;
\end_layout

\begin_layout Plain Layout

        b = 0;
\end_layout

\begin_layout Plain Layout

        #dl;
\end_layout

\begin_layout Plain Layout

        if(m != 0) $display("Multiply error*: 0*0 =? 0");
\end_layout

\begin_layout Plain Layout

        $dumpflush;
\end_layout

\begin_layout Plain Layout

        $finish;
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

endmodule
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Метрики кода
\end_layout

\begin_layout Subsection
Процессор УП-1
\end_layout

\begin_layout Standard
В таблице 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:cpu32mt"

\end_inset

 представлены метрики кода проекта процессора УП-1.
 Файл mult.v в основной расчёт (без скобок) не берётся, т.к.
 он сгенерирован программой из проекта MultiplierGenerator.
 Число в скобках отображает метрики с включением сгенерированного mult.v.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="19" columns="5">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="decimal" decimal_point="." valignment="top">
<column alignment="decimal" decimal_point="." valignment="top">
<column alignment="decimal" decimal_point="." valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Файл
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Язык
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Пустых строк
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Комментариев
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Строк кода
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mult.v (GENERATED)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Verilog
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- (17)
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- (3)
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- (4123)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
insn_decoder.v 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Verilog
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
43
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
148
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
530
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
main.v
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Verilog
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
265
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
memory_op.v
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Verilog
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
33
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
211
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
alu.v
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Verilog
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
44
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
197
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
shift.v
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Verilog
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
57
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
53
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
158
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
test_pipeline_assembly.v
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Verilog
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
51
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
130
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
execute.v
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Verilog
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
102
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
adder.v
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Verilog
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
29
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
82
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ram.v
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Verilog
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
78
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pipeline_interface.v
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Verilog
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
77
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
gpio_mux.v
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Verilog
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
69
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
register_wb.v
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Verilog
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
66
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
gpio.v
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Verilog
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
51
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
test_periph_assembly.v
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Verilog
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
41
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
regs.v
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Verilog
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
37
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
test_processor_assembly.v
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Verilog
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ВСЕГО
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Verilog
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
387 (404)
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
339 (342)
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2126 (6249)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:cpu32mt"

\end_inset

Метрики кода проекта CPU32
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
MultiplierGenerator
\end_layout

\begin_layout Standard
В таблице 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:multgenmt"

\end_inset

 представлены метрики кода проекта генератора уможителей Дадды
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="5">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="decimal" decimal_point="." valignment="top">
<column alignment="decimal" decimal_point="." valignment="top">
<column alignment="decimal" decimal_point="." valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Файл
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Язык
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Пустых строк
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Комментариев
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Строк кода
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Gate.hpp
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C++
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
71
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
354
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
testcase.v
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Verilog
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
36
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Main.cpp
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C++
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="left" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ВСЕГО
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C++
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
83
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
378
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Verilog
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
36
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ВСЕ
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
91
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
414
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:multgenmt"

\end_inset

Метрики кода проекта MultiplierGenerator
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_body
\end_document
